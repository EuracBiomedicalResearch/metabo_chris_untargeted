---
title: "CHRIS preprocessing posititve mode"
author: "Marilyn De Graeve, Philippine Louail, Johannes Rainer"
affiliation: "Eurac Research, Bolzano, Italy"
date: "2024-02-28"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
    code_folding: hide
editor_options:
  markdown:
    wrap: 72
bibliography: references.bib
---

**Modified**: `r file.info("CHRIS_preprocessing_pos.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r style, message = FALSE, echo = FALSE, warning = FALSE, results = "asis"}
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now, units = "secs")
      # return a character string to show the time
      paste("Time for this code chunk to run:", round(res,
        2), "seconds")
    }
  }
}))

suppressMessages(library("BiocStyle"))
suppressMessages(library("kableExtra"))
suppressMessages(library("knitr"))
suppressMessages(library("rmarkdown"))
opts_chunk$set(message = FALSE, error = FALSE, warning = FALSE,
               cache = FALSE, fig.width = 7, fig.height = 7, time_it = TRUE)

```

# Introduction

During this workflow, the preprocessing (PP) of the untargeted metabolomics data
of the Cooperative Health Research in South Tirol (CHRIS) study is
performed. For a description of the study, methods used for the collection,
handling and aqcuisition of the liquid chromatography-mass spectrometry (LC-MS)
samples, please see [@verri_hernandes_age_2022]. Samples are aquired in both
positive and negative ionization mode, for which the PP of the positive (pos)
mode will be performed in this Rmarkdown document.

# Setup

## Directories

```{r directories, echo = FALSE}
#' General settings
filename <- " CHRIS_preprocessing_pos"

#' Path to save images to; remove if exists.
IMAGE_PATH <- paste0("images/", filename, "/")
if (file.exists(IMAGE_PATH))
    unlink(IMAGE_PATH, recursive = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE)

#' Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
dir.create(RDATA_PATH, recursive = TRUE, showWarnings = FALSE)

#' Path to the data
DATA_PATH <- '/media/mdegraeve/josung/data/CHRIS'     #'data' #FINDME!

```

## Packages

```{r packages, message=FALSE}
#' Load libraries
suppressMessages(library(magick))
suppressMessages(library(MetaboAnnotation))
suppressMessages(library(MetaboCoreUtils))
suppressMessages(library(MsBackendSql))
suppressMessages(library(MsExperiment))
suppressMessages(library(MsQuality))
suppressMessages(library(pander))
suppressMessages(library(pheatmap))
suppressMessages(library(RColorBrewer))
suppressMessages(library(readxl))
suppressMessages(library(RSQLite))
suppressMessages(library(Spectra))
suppressMessages(library(SummarizedExperiment))
suppressMessages(library(vioplot))
suppressMessages(library(xcms))

```

## Computation

```{r parallel_processing_setup, message=FALSE}
#' Set up parallel processing using multiple cores
NR_CORES <- as.integer(8)              ###FINDME!!!
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(NR_CORES)))
} else {
    register(bpstart(SnowParam(NR_CORES)))
}

```


# Data import

Create a `MsExperiment` called `chris` representing the data.
we restrict the dataset by:

- excluding badly aqcuired samples which were replicated using re-injection of
the sample plate (BPLT00000411\_R2 and BPLT00000407_R);
- the additional (extended)
quality control samples available for some batches (i.e., the *pool dilution
series* samples);
- RT filter to actual LC-MS acquisition window;
- select only batch.


```{r load_dataa}
#' Load the spectra data from the database
handle <- file.path(DATA_PATH, 'chris_hilic_pos_1.0.0.2.sqlite')
s <- Spectra(handle, source = MsBackendOfflineSql(), drv = SQLite())

#' create an MsExperiment
chris <- MsExperiment(spectra = s)

#' Remove batch BATCH155 and BATCH134
chris <- chris[!sampleData(chris)$batch_id %in% c("BATCH0134", "BATCH0155")]

#' Restrict to Blank, Study and Pool samples
chris <- chris[sampleData(chris)$sample_type %in% c("Blank", "Pool", "Study")]

#' Filter for ret time
chris <- filterRt(chris, c(10, 250))

#' Select the middle batch only (see PCA overview)
chris <- chris[grep(unique(sampleData(chris)$batch_id)[45],
                    sampleData(chris)$batch_id, fixed = TRUE)]

print('batch_id:')
sampleData(chris)$batch_id[45]
print('nr of samples in small subset of chris:')
length(chris)

```

Below a view of the sampleData of the chris MsExperiment with some random
samples.

```{r sampleData, echo=FALSE, results="asis"}
sampleData(chris)[, c(5, 10, 11, 13)] |>
    as.data.frame() |>
    head() |>
    pandoc.table(style = "rmarkdown",
                 caption = "Some samples from the data set.")
```

The number of samples for the various *sample types* are:

```{r, results = "asis"}
#' table with nr of study, pool and blank samples
table(sampleData(chris)$sample_type) |>
    as.data.frame() |>
    pandoc.table(style = "rmarkdown",
                 caption = "Numer of samples per sample type")
```
For which we define colors.

```{r define_colors, include=FALSE}
#' Define colors for the groups.
#' color code according to sample_type
col_sampletype <- brewer.pal(8, "Accent")[c(1, 5, 8)]
names(col_sampletype) <- c("Study", "Pool", "Blank")

#' match color to sample_type
col_samples <- col_sampletype[sampleData(chris)$sample_type]

#' Define a unique color for each batch.
col_batch <- rainbow(length(unique(sampleData(chris)$batch_id)))
names(col_batch) <- unique(sampleData(chris)$batch_id)

```


# Preprocessing

## Chromatographic peak detection

finding cwp parameter

- peakwidth: observing previous EIC, expecting between 2 to 20s
- ppm:

```{r ppm_parameter decide on 1 sample}
#' choose a nice compound here
cystine_mz <- calculateMass("C6H12N2O4S2") |>
  mass2mz("[M+H]+")

cystine_mz <- cystine_mz[1, 1]

#' plot to see rt range for one sample
cst <- chromatogram(chris[1L],
                    rt = c(200, 220),
                    mz = cystine_mz + c(-0.01, 0.01)) #aprox 50ppm
plot(cst)


#' plot to see rt range for one batch
cst <- chromatogram(chris[grep(unique(sampleData(chris)$batch_id)[1],
                               sampleData(chris)$batch_id, fixed = TRUE)],
                    rt = c(200, 220),
                    mz = cystine_mz + c(-0.01, 0.01),
                    chunkSize = NR_CORES)
plot(cst,
     col = paste0(col_samples[cst$sample_type], 60),
     main = "EIC for cystine one batch")


#' Restrict the data to signal from Cystine in 1 sample
cst <- chris[1L] |>
    spectra() |>
    filterRt(rt = c(210, 220)) |>                      #not outside peak, only to retrieve ppm. can be done with apex
    filterMzRange(mz = cystine_mz + c(-0.01, 0.01))
#lengths(cst)                                           #only keep spectra whitin peaks, need to be all value '1'
min(lengths(cst))

#' Calculate the difference in m/z values between scans
mz_diff <- cst |>
    mz() |>
    unlist() |>
    diff() |>
    abs()

#' Express it in ppm
print('ppm range detected across samples:')
range(mz_diff * 1e6 / mean(unlist(mz(cst))))  #2.6 ppm for batch[45] == BATCH0088

```

The *m/z* ranges up `r range(mz_diff * 1e6 / mean(unlist(mz(cst))))[2]` ppm,
which was good.

But can also see skew to the right on the EIC (see plots generated in the
general\_data_overview) for most of the standards. So choose a largerpeak width
(20s) to accommodate.

```{r check with 2 EICs ppm ok}
##' example 1
#' #' extract test ion
#' cystine
eic_cystine <- chromatogram(chris,
                            rt = c(200, 220),
                            mz = cystine_mz + c(-0.01, 0.01),
                            chunkSize = NR_CORES)


##' example 2
#' histidine
his_mz <- calculateMass("C6H9N3O2") |>
  mass2mz("[M+H]+")

his_mz <- his_mz[1, 1]

#' expected mz_diff
#PPM <- 5
#his_mz*PPM*10/1e6
#his_mz - (his_mz*10/1e6)
#his_mz + (his_mz*10/1e6)

#' extract EIC
eic_his <- chromatogram(chris,
                        rt = c(185, 195),
                        mz = his_mz + c(-0.01, 0.01),
                        chunkSize = NR_CORES)

#' for testing below only (one batch):
#plot(eic_his,
#     col = paste0(col_samples[eic_his$sample_type], 60),
#     main = "EIC for histidine")

#' Restrict the data to signal from Cystine for all samples
#his <- chris |>
#    spectra() |>
#    filterRt(rt = c(188, 190)) |>
#    filterMzRange(mz = his_mz + c(-0.001, 0.001))
#lengths(his)
#min(lengths(his))

#' Calculate the difference in m/z values between scans
#mz_diff <- his |>
#    mz() |>
#    unlist() |>
#    diff() |>
#    abs()

#' Express it in ppm
#print('ppm range detected across samples:')
#range(mz_diff * 1e6 / mean(unlist(mz(his))))  #4.8 ppm for batch[45] == BATCH0088

```

Select the peak picking parameters with a large ppm (default 40ppm) and a very low
signal to noise ratio (snthresh), as needed to find the example peaks.

```{r echo=TRUE, warning=FALSE}
param <- CentWaveParam(peakwidth = c(2, 20), ppm = 40, snthresh = 2,  #put ppm here always 40, NS was needed <3 here
                       integrate = 2)

```

perform peak picking on 2 examples.

```{r include=FALSE}
#' test for some compounds:
#' cystine
cystine_test <- findChromPeaks(eic_cystine, param = param, chunkSize = NR_CORES)
head(chromPeaks(cystine_test))

#' histidine
his_test <- findChromPeaks(eic_his, param = param, chunkSize = NR_CORES)
head(chromPeaks(his_test))

```

show plots for 2 examples

```{r include=FALSE}
#' Plot test chromatogram
par(mfrow = c(1, 2))
plot(cystine_test,
     main = "Cystine",
     col = paste0(col_samples, 60),
     peakCol = col_samples[chromPeaks(cystine_test)[, "column"]],
     peakBg = paste0(col_samples, 10)[chromPeaks(cystine_test)[, "column"]])
grid()

plot(his_test,
     main = "Histidine",
     col = paste0(col_samples, 60),
     peakCol = col_samples[chromPeaks(his_test)[, "column"]],
     peakBg = paste0(col_samples, 10)[chromPeaks(his_test)[, "column"]])
grid()
legend("topright", inset=c(-0,0), col = col_sampletype, legend = names(col_sampletype),
       ncol = 1, lty = 1, cex=.8)

```

OK, apply to all data:

```{r findchrompeaks_all_data, echo=TRUE, eval = !file.exists("chris_after_peakdetect.RData")}
chris <- findChromPeaks(chris, param = param, chunkSize = NR_CORES)
save(chris, file = paste0(RDATA_PATH, "chris_after_peakdetect.RData"))
```

```{r, echo = FALSE, eval = file.exists("chris_after_peakdetect.RData")}
#' Loading the already peak-detected data
load(paste0(RDATA_PATH, "chris_after_peakdetect.RData"))
```

We next remove samples in which a much lower number of peaks was detected.

```{r, results = "asis"}
#' remove samples that have overall low intensity/peak detected,
#' as safety net for bad samples that were detected after PP -> rm here using below chunk
index <- as.vector(table(chromPeaks(chris)[, "sample"]) < 1500)
print('nr of samples removed:')
length(which(index))

sampleData(chris)[index, c("year", "sample_type", "batch_id")] |>
    as.data.frame() |>
    pandoc.table(
        style = "rmarkdown",
        caption = "Samples that will be removed because of too few detected peaks.")

if (length(which(index)) > 0) {
    chris <- chris[!index]
    }
print('nr of samples remain:')
length(chris)

#' Update indices and colors.
col_samples <- col_sampletype[sampleData(chris)$sample_type]
col_batches <- col_batch[sampleData(chris)$batch_id]
pool_index <- which(sampleData(chris)$sample_type == "Pool")
batches_pool <- col_batch[sampleData(chris)$batch_id][pool_index]

```

```{r, include=FALSE}
#' test for ions of interest
eic_cystine <- chromatogram(chris,
                            rt = c(202, 217),
                            mz = cystine_mz + c(-0.01, 0.01),
                            aggregationFun = "max",
                            chunkSize = NR_CORES)

eic_his <- chromatogram(chris,
                        rt = c(172, 203),
                        mz = his_mz + c(-0.01, 0.01),
                        aggregationFun = "max",
                        chunkSize = NR_CORES)

par(mfrow = c(1, 2))
plot(eic_cystine, main = "Cystine", col = paste0(col_samples, 80),
     peakCol = col_samples[chromPeaks(eic_cystine)[, "sample"]],
     peakBg = paste0(col_samples[chromPeaks(eic_cystine)[, "sample"]], 40))
grid()
plot(eic_his, main = "Histidine", col = paste0(col_samples, 80),
     peakCol = col_samples[chromPeaks(eic_his)[, "sample"]],
     peakBg = paste0(col_samples[chromPeaks(eic_his)[, "sample"]], 40))
grid()
legend("topright", col = col_sampletype, cex = 0.50,
       horiz = TRUE,inset = c(-0.18, -0.1), xpd = TRUE,
       text.width = 7, bty = "n",
       legend = names(col_sampletype), lty = 1)
```

check all the good quality (internal) stardards, see list in general\_data_overview report.
load this file first.

```{r load standers list}
##' list 3: standards_chris_pos
#' load the good quality internal and in-house standards list, see creation at general_data_overview.Rmd
standards_chris_pos <- read.delim(file.path(DATA_PATH, "standards_chris_pos.txt"))
standards_chris_pos <- standards_chris_pos[!is.na(standards_chris_pos$POS), ]
rownames(standards_chris_pos) <- standards_chris_pos$abbreviation
#standards_chris_pos
#nrow(standards_chris_pos)

```

create EIC plots for all standards in pool.

```{r, include=FALSE}
#' All EICs in pool
eics <- chromatogram(chris[pool_index],
                     mz = as.matrix(standards_chris_pos[, c("mzmin", "mzmax")]),
                     rt = as.matrix(standards_chris_pos[, c("rtmin", "rtmax")]),
                     chunkSize = NR_CORES)

dr <- file.path(IMAGE_PATH, "EIC_standards/Pool_batch/afterchrompeak/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)

for (i in seq_len(nrow(standards_chris_pos))) {
    png(paste0(dr, "EIC_", standards_chris_pos$abbreviation[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(eics[i], main = standards_chris_pos$name[i], col = paste0(batches_pool,80),
         peakCol = col_batches[chromPeaks(eics[i])[, "sample"]],
         peakBg = paste0(col_batches[chromPeaks(eics[i])[, "sample"]], 40))
    grid()
    legend("topright", col = col_batch,
           legend = names(col_batch), lty = 1)
    legend("topleft",
           legend = paste0("m/z: ", format(fData(eics)$mzmin[i], 4),
                             " - ", format(fData(eics)$mzmax[i], 4)))
    abline(v = standards_chris_pos$RT[i], col = "red", lty = 3)
    dev.off()
}


```

Look at the nb of peak per files

```{r, fig.cap = "Numbers of detected peaks per sample."}
#' Count peaks per file
chromPeaks(chris)[, "sample"] |>
    table() |>
    barplot(border = col_samples, col = col_samples)
grid()
```


### Refine chromatographic peaks


```{r refine_chrom_peaks,  message = FALSE, eval = !file.exists("chris_after_refine.RData")}
#' set up the parameter
param <- MergeNeighboringPeaksParam(expandRt = 5,
                                    expandMz = 0.001,
                                    ppm = 5,
                                    minProp = 0.75)
#' apply to all dataset
chris <- refineChromPeaks(chris, param = param, chunkSize = NR_CORES)
save(chris, file = paste0(RDATA_PATH, "chris_after_refine.RData"))
```

```{r load_refine_chrom_peaks, include=FALSE, eval = file.exists("chris_after_refine.RData")}
load(paste0(RDATA_PATH, "chris_after_refine.RData"))
```

```{r echo=TRUE, fig.cap = "Numbers of detected peaks per sample after peak refinement."}
#' Count peaks per file
chromPeaks(chris)[, "sample"] |>
    table() |>
    barplot(border = col_samples, col = col_samples)
grid()
```

```{r include=FALSE}
#' All EICs in pool
eics <- chromatogram(chris[pool_index],
                     mz = as.matrix(standards_chris_pos[, c("mzmin", "mzmax")]),
                     rt = as.matrix(standards_chris_pos[, c("rtmin", "rtmax")]),
                     chunkSize = NR_CORES)

dr <- file.path(IMAGE_PATH, "EIC_standards/Pool_batch/afterrefine/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)

for (i in seq_len(nrow(standards_chris_pos))) {
    png(paste0(dr, "EIC_", standards_chris_pos$abbreviation[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    eic <- eics[i]
    plot(eic, main =standards_chris_pos$name[i], col = paste0(batches_pool, 80),
         peakCol = col_batches[chromPeaks(eic)[, "sample"]],
         peakBg = paste0(col_batches[chromPeaks(eic)[, "sample"]], 40))
    grid()
    legend("topright", col = col_batch,
           legend = names(col_batch), lty = 1)
    legend("topleft",
           legend = paste0("m/z: ", format(fData(eic)$mzmin, 4),
                           " - ", format(fData(eic)$mzmax, 4)))
    abline(v = standards_chris_pos$RT[i], col = "red", lty = 3)
    dev.off()
}


```

## Retention time alignment

Multiple strategies were tested in a separate Rmd file. The current approach
based on a single alignment based on retention times of internal standards and
manually selected standards. This approach outperformed also a two-step
alignment setup in which a *standard* alignment was performed after the initial
alignment based on the above mentioned standards.

```{r reorder_data_set}
#' keep a raw chris object to compare before/after alignment
chris_raw <- chris

#' Reorganising samples order for alignment
#' saving old order
sampleData(chris)$original_index <- seq_along(chris)

#' determining new order
sd <- as.data.frame(sampleData(chris))
tmp <- lapply(split(sd, sd$batch_id), function(batch){
    qcs <- which(batch$sample_type == "Pool")
    indices <- batch$original_index
    first <- min(qcs)
    last <- max(qcs)
    c(indices[first], indices[-c(first, last)], indices[last])
})

index_qc <- unlist(tmp, use.names = FALSE)

#' applying it
chris <- chris[index_qc]

#' Update indices and colors.
col_samples <- col_sampletype[sampleData(chris)$sample_type]
col_batches <- col_batch[sampleData(chris)$batch_id]
pool_index <- which(sampleData(chris)$sample_type == "Pool")
batches_pool <- col_batch[sampleData(chris)$batch_id][pool_index]
```

One run based on a pre-defined peak matrix of IS standards and manually selected
standards with rt for each Pool samples. Below we define this peak matrix and
extract the retention times for the selected chromatographic peak for each
sample.

```{r alignment_using_selected_standards}
#' creating matrix for rt alignment
mixAlignment_df <- read.delim(file.path(DATA_PATH, "Mix_alignment.txt"))
mixAlignment_df <- mixAlignment_df[!is.na(mixAlignment_df$POS), ]
rownames(mixAlignment_df) <- mixAlignment_df$abbreviation
#mixAlignment_df
mixAlignment_df <- mixAlignment_df[order(mixAlignment_df$RT),]

#' loop results
ID_table <- matrix(
    ncol = length(chris),
    nrow = nrow(mixAlignment_df),
    dimnames = list(c(row.names(mixAlignment_df)), c(seq_len(length(chris))))
)

cpks <- as.data.frame(chromPeaks(chris))
cpks$peak_id <- rownames(cpks)

#' get ID for peaks matching with IS for each samples (minus Blanks)
for (i in which(sampleData(chris)$sample_type != "Blank")) {
    tmp <- cpks[cpks$sample == i, ]
    match_intern_standard <- matchValues(
        query = mixAlignment_df,
        target = tmp,
        mzColname = c("mz", "mz"),
        rtColname = c("RT", "rt" ),
        param = MzRtParam(ppm = 0, tolerance = 0.01, toleranceRt = 10))
    #' Select the chrom peak with the largest apex signal
    match_intern_standard <- filterMatches(
        match_intern_standard, SingleMatchParam(duplicates = "top_ranked",
                                                decreasing = TRUE,
                                                column = "target_maxo"))
    ID_table[, i] <- match_intern_standard$target_peak_id
}

#' Function to create rt dataframe;
#' avoiding subset with NA turns out to be much more efficient
rtdf <- function(chris, ID_table) {
    index <- as.vector(ID_table)
    nna <- !is.na(index)
    x <- rep(NA, length(index))
    x[nna] <- chromPeaks(chris)[index[nna], "rt"]
    dim(x) <- dim(ID_table)
    rownames(x) <- rownames(ID_table)
    colnames(x) <- colnames(ID_table)
    x
}

#' run for chris
RT_raw <- rtdf(chris, ID_table)

```

We repeat the same for the full set of standards (which are not used for the
alignment) to allow an independent evaluation of the alignment performance.

```{r define_rtimes_all_standards}
#' Identify chromPeaks for all standards
standards_all_cpeaks <- matrix(
    ncol = length(chris),
    nrow = nrow(standards_chris_pos),
    dimnames = list(rownames(standards_chris_pos), seq_len(length(chris)))
)

#' get ID for peaks matching with standard for each samples (minus Blanks)
for (i in which(sampleData(chris)$sample_type != "Blank")) {
    tmp <- cpks[cpks$sample == i, ]
    match_standard <- matchValues(
        query = standards_chris_pos,
        target = tmp,
        mzColname = c("mz", "mz"),
        rtColname = c("RT", "rt" ),
        param = MzRtParam(ppm = 0, tolerance = 0.01, toleranceRt = 10))
    match_standard <- filterMatches(
        match_standard, SingleMatchParam(duplicates = "top_ranked",
                                         decreasing = TRUE,
                                         column = "target_maxo"))
    standards_all_cpeaks[, i] <- match_standard$target_peak_id
}

#' Remove those that are already included in Mix_standard
standards_all_cpeaks <- standards_all_cpeaks[
    !rownames(standards_all_cpeaks) %in% rownames(mixAlignment_df), ]

#' run for chris
standards_all_rtime_raw <- rtdf(chris, standards_all_cpeaks)

```

Next we perform the alignment based on retention times of internal standards and
manually selected standards (to cover a larger retention time range). We perform
the alignment on all samples (except blanks, which will be aligned based on all
study or QC samples). A subset-based alignment on QC (pool) samples performed
less well.

```{r perform_alignment_on_standards}
#' Subset to all samples except blanks
is_blank <- sampleData(chris)$sample_type == "Blank"
final_table <- RT_raw[, !is_blank]

#' Order by median RT
final_table <- final_table[order(rowMedians(final_table, na.rm = TRUE)), ]

#' run with that first
#' Define parameters of choice
#' if error in function PeakGroupsParam, update all BiocManager packages first to devel version
#' https://rdrr.io/bioc/xcms/man/adjustRtime-peakGroups.html
param <- PeakGroupsParam(span = 0.5,
                         peakGroupsMatrix = final_table,
                         subset = which(!is_blank),
                         subsetAdjust = "average")
chris <- adjustRtime(chris, param = param, chunkSize = NR_CORES)

#' Define color, less transparency for the Pool samples
alpha <- rep("60", length(col_samples))
alpha[pool_index] <- "CE"
cols <- paste0(col_samples, alpha)

plotAdjustedRtime(chris, col = cols)
grid()
legend("topright", col = col_sampletype,
       legend = names(col_sampletype), lty = 1)

cols <- paste0(col_batches, alpha)
plotAdjustedRtime(chris, col = cols)
grid()
legend("topright", col = col_batch,
       legend = names(col_batch), lty = 1)

#' Replace the Rtime by the adjusted ones
chris <- applyAdjustedRtime(chris)
```

Next we evaluate the result of the alignment on the set of standards on which
the alignment was based. These are listed in the table below.

```{r, results = "asis"}
#' get RT table after alignment
RT_aligned <- rtdf(chris, ID_table)

#' Get RT table only for study samples
index_s <- sampleData(chris)$sample_type == "Study"

Sdsdf <- data.frame(
    Raw_pool = rowSds(RT_raw[, pool_index], na.rm = TRUE),
    Aligned_pool = rowSds(RT_aligned[, pool_index], na.rm = TRUE),
    Raw_study = rowSds(RT_raw[, index_s], na.rm = TRUE),
    Aligned_study = rowSds(RT_aligned[, index_s], na.rm = TRUE)
)

pandoc.table(
    Sdsdf, style = "rmarkdown", split.table = Inf,
    caption = paste0("Standards on which the alignment was based along with ",
                     "the standard deviation of their retention times before ",
                     "and after alignment in QC and study samples."))
```

```{r}
par(mar = c(1.3, 4.5, 1, 0.5))
vioplot(Sdsdf, las = 2, ylab = "RT standard deviation",
        main = "Standards used for alignment")
grid()
```

Looks pretty cool

In addition, we base the evaluation of the alignment also on compounds not used
as anchor peaks hence allowing an independent evaluation of the performance.

```{r, results = "asis"}
#' get RT table after alignment
standards_all_rtime_adj <- rtdf(chris, standards_all_cpeaks)

tmp <- data.frame(
    Raw_pool = rowSds(standards_all_rtime_raw[, pool_index], na.rm = TRUE),
    Aligned_pool = rowSds(standards_all_rtime_adj[, pool_index], na.rm = TRUE),
    Raw_study = rowSds(standards_all_rtime_raw[, index_s], na.rm = TRUE),
    Aligned_study = rowSds(standards_all_rtime_adj[, index_s], na.rm = TRUE)
)

pandoc.table(
    tmp, style = "rmarkdown", split.table = Inf,
    caption = paste0("Standards not used for alignment along with ",
                     "the standard deviation of their retention times before ",
                     "and after alignment in QC and study samples."))
```

```{r}
par(mar = c(1.3, 4.5, 1, 0.5))
vioplot(tmp, las = 2, ylab = "RT standard deviation",
        main = "Standards not used for alignment")
grid()
```

```{r bpc-before-and-after, echo=FALSE}
#' replace value to not have problems when indexing
if (hasAdjustedRtime(chris))
    chris <- applyAdjustedRtime(chris)

chris <- chris[order(sampleData(chris)$original_index),
               keepFeatures = TRUE,
               keepAdjustedRtime = TRUE]

#' Update indices and colors.
col_samples <- col_sampletype[sampleData(chris)$sample_type]
col_batches <- col_batch[sampleData(chris)$batch_id]
pool_index <- which(sampleData(chris)$sample_type == "Pool")
batches_pool <- col_batch[sampleData(chris)$batch_id][pool_index]
chris_pool <- chris[pool_index, keepAdjustedRtime = TRUE]
chris_raw_pool <- chris_raw[pool_index, keepAdjustedRtime = TRUE]

#' Plot the BPC before and after alignment
par(mfrow = c(2, 1), mar = c(2, 1, 1, 0.5))
chromatogram(chris_raw_pool,
             aggregationFun = "max",
             chromPeaks = "none",
             chunkSize = NR_CORES) |>
    plot(main = "BPC of pool before alignment",
         col = paste0(batches_pool, 60))
grid()

chromatogram(chris_pool,
             aggregationFun = "max",
             chromPeaks = "none",
             chunkSize = NR_CORES) |>
    plot(main = "BPC of pool after alignment",
         col = paste0(batches_pool, 60))
grid()
legend("topright", col = col_batch, cex = 0.50,
       horiz = TRUE,inset = c(-0.18, -0.1), xpd = TRUE,
       text.width = 7, bty = "n",
       legend = names(col_batch), lty = 1)

```

```{r selected_eics_after_alignment}
#' standard after alignment
par(mfrow = c(1, 2), mar = c(4, 4.5, 2, 0.5))
plot(eic_cystine[1, pool_index], peakType = "none",
     main = "Cystine in pool before alignment",
     col = paste0(batches_pool, 80))
grid()
abline(v = 211 , col = "red", lty = 3)

eic_cystine <- chromatogram(chris, rt = c(201, 220),
                            mz = cystine_mz + c(-0.01, 0.01),
                            chunkSize = NR_CORES)
plot(eic_cystine[1, pool_index], peakType = "none",
     main = "Cystine in pool after alignment",
     col = paste0(batches_pool,80))
     grid()
     abline(v = 211 , col = "red", lty = 3)
legend("topright", col = col_batch, cex = 0.50,
       horiz = TRUE,inset = c(-0.18, -0.1), xpd = TRUE,
       text.width = 7, bty = "n",
       legend = names(col_batch), lty = 1)


par(mfrow = c(1, 2), mar = c(4, 4.5, 2, 0.5))
plot(eic_his[1, pool_index], peakType = "none",
     main = "Histidine in pool before alignment",
     col = paste0(batches_pool,80))
     grid()
     abline(v = 188 , col = "red", lty = 3)

eic_his <- chromatogram(chris, rt = c(170, 200),
                        mz = his_mz + c(-0.01, 0.01),
                        chunkSize = NR_CORES)
plot(eic_his[1, pool_index], peakType = "none",
     main = "Histidine in pool after alignment",
     col = paste0(batches_pool,80))
     grid()
     abline(v = 188 , col = "red", lty = 3)
     legend("topright", col = col_batch, cex = 0.50,
            horiz = TRUE,inset = c(-0.18, -0.1), xpd = TRUE,
            text.width = 7, bty = "n",
            legend = names(col_batch), lty = 1)

```

```{r EIC-pool-after-alignment, include=FALSE}
eics <- chromatogram(chris_pool,
                     mz = as.matrix(standards_chris_pos[, c("mzmin", "mzmax")]),
                     rt = as.matrix(standards_chris_pos[, c("rtmin", "rtmax")]),
                     chromPeaks = "none", chunkSize = NR_CORES)

dr <- file.path(IMAGE_PATH, "EIC_standards/Pool_batch/afteralignment/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)

for (i in seq_len(nrow(standards_chris_pos))) {
    png(paste0(dr, "EIC_", standards_chris_pos$abbreviation[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(eics[i], main =standards_chris_pos$name[i],
         col = batches_pool,
         peakType = "none")
    grid()
    legend("topright", col = col_batch,
           legend = names(col_batch), lty = 1)
    abline(v = standards_chris_pos$RT[i], col = "red", lty = 3)
    legend("topleft",
           legend = paste0("m/z: ", format(fData(eics)$mzmin[i], 4),
                             " - ", format(fData(eics)$mzmax[i], 4)))
    dev.off()
}

#' Extract the EICs
eics <- chromatogram(chris,
                     mz = as.matrix(standards_chris_pos[, c("mzmin", "mzmax")]),
                     rt = as.matrix(standards_chris_pos[, c("rtmin", "rtmax")]),
                     chromPeaks = "none", chunkSize = NR_CORES)

dr <- file.path(IMAGE_PATH, "EIC_standards/full/afteralignment/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_len(nrow(standards_chris_pos))) {
    png(paste0(dr, "EIC_", standards_chris_pos$abbreviation[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(eics[i],
         main =standards_chris_pos$name[i],
         col = col_samples,
         peakType = "none")
    grid()
    legend("topright",
           col = col_sampletype,
           legend = names(col_sampletype), lty = 1)
    legend("topleft",
           legend = paste0("m/z: ", format(fData(eics)$mzmin[i], 4),
                             " - ", format(fData(eics)$mzmax[i], 4)))
    abline(v = standards_chris_pos$RT[i], col = "red", lty = 3)
    dev.off()
}


```


```{r include=FALSE}
save(chris, file = paste0(RDATA_PATH, "chris_after_alignment.RData"))
```

## Correspondence

```{r}
#' Updating parameters
param <- PeakDensityParam(
    sampleGroups = sampleData(chris)$sample_type[pool_index],
    minFraction = 0.5, binSize = 0.01, ppm = 10, bw = 2)


plotChromPeakDensity(
    eic_cystine[1, pool_index],
    param = param,
    col = paste0(batches_pool, 80),
    peakCol = col_batches[chromPeaks(eic_cystine[1, pool_index])[, "sample"]],
    peakBg = paste0(col_batches[chromPeaks(eic_cystine[1, pool_index])[, "sample"]], 20),
    peakPch = 16
    )
legend("bottomright", col = col_batch, cex = 0.50,
       horiz = TRUE, inset = c(0, -0.5), xpd = TRUE,
       text.width = 4, bty = "n",
       legend = names(col_batch), lty = 1)

plotChromPeakDensity(
    eic_his[1, pool_index],
    param = param,
    col = paste0(batches_pool, 80),
    peakCol = col_batches[chromPeaks(eic_his[1, pool_index])[, "sample"]],
    peakBg = paste0(col_batches[chromPeaks(eic_his[1, pool_index])[, "sample"]], 20),
    peakPch = 16
    )
legend("bottomright", col = col_batch, cex = 0.50,
       horiz = TRUE,inset = c(0, -0.5), xpd = TRUE,
       text.width = 4, bty = "n",
       legend = names(col_batch), lty = 1)
```

For the final correspondence we reduce the required proportion in which a
chromatographic peak has to be present to 30% to ensure that features
representing metabolites present also in only a subset of study samples would be
defined/present. Also, we use m/z-dependent bin sizes (i.e., m/z bins increase
by `ppm` along the m/z dimension). For this we reduce in addition the `binSize`
from 0.015 to 0.01. Thus, the final (largest) bin size for an m/z of 1000 will
be `0.01 + ppm(1000, ppm = 10)` which is equal to 0.02.

```{r perform_correspondence}
#' Now apply to whole data
param <- PeakDensityParam(sampleGroups = sampleData(chris)$sample_type,
                          minFraction = 0.3, binSize = 0.01, ppm = 10,
                          bw = 2)
chris <- groupChromPeaks(chris, param = param)

#' Extract pool_sample for better visualization of analysis
chris_pool <- chris[pool_index, keepAdjustedRtime = TRUE, keepFeatures = TRUE]
```

```{r}
#' Extract chromatogram with signal for isomers 1-Methylhistidine and
#' 3-Methylhistidine
met_mz <- calculateMass("C7H11N3O2")
met_mz <- mass2mz(met_mz, adduct = "[M+H]+")[1,]
chr_test <- chromatogram(chris, mz = met_mz + c(-0.01, 0.01),
                         rt = c(160, 200), chunkSize = NR_CORES)

plotChromPeakDensity(chr_test, col = paste0(col_batches, 80),
    peakCol = paste0(col_batches[chromPeaks(chr_test)[, "sample"]], 80),
    peakBg = paste0(col_batches[chromPeaks(chr_test)[, "sample"]], 20),
    peakPch = 16, simulate = FALSE)
legend("bottomright", col = col_batch, cex = 0.50,
       horiz = TRUE,inset = c(0, -0.5), xpd = TRUE,
       text.width = 4, bty = "n",
       legend = names(col_batch), lty = 1)

```

```{r include=FALSE}
save(chris, file = paste0(RDATA_PATH, "chris_after_correspondence.RData"))
```

Correspondence defined in total `r nrow(featureDefinitions(chris))`
features. Below we evaluate the m/z (and rt) widths of the identified features.

```{r}
#' Define the m/z and rt widths considering the apex position.
apex_mzw <- featureDefinitions(chris)$mzmax - featureDefinitions(chris)$mzmin
apex_rtw <- featureDefinitions(chris)$rtmax - featureDefinitions(chris)$rtmin

#' Define the m/z and rt widths considering the full chrom peak ranges.
feature_area <- featureArea(
    chris, features = rownames(featureDefinitions(chris)))
full_mzw <- feature_area[, "mzmax"] - feature_area[, "mzmin"]
full_rtw <- feature_area[, "rtmax"] - feature_area[, "rtmin"]
```

The distribution of m/z widths for all features is:

```{r}
quantile(apex_mzw)
```

The distribution of rt widths for all features is:

```{r}
quantile(apex_rtw)
```

We first evaluate the rt and m/z widths of features considering the apex
positions of all chrom peaks of a feature.

```{r, fig.cap = "Features' median retention time against rt widths (for the apex position of chrom peaks) and features' median m/z against m/z width (of apex)."}
par(mfrow = c(1, 2))
plot(featureDefinitions(chris)$rtmed, apex_rtw, xlab = "rt",
     ylab = "rt width", main = "chrom peak apex", pch = 21,
     col = "#00000040", bg = "#00000020")
grid()
plot(featureDefinitions(chris)$mzmed, apex_mzw, xlab = "m/z",
     ylab = "m/z width", main = "chrom peak apex", pch = 21,
     col = "#00000040", bg = "#00000020")
grid()
```

In the begin and at the end of LC, retention time widths seem to be on average lower than in the
middle of the LC. For features' m/z widths there is a clear
dependency on the median m/z, which is due to the settings in the correspondence
analysis that uses m/z dependent bin sizes for the correspondence.

We next evaluate the rt and m/z widths of features considering the full range of
m/z and rt values of all chromatographic peaks of a feature. The distribution
for the full m/z range of all chromatographic peaks per feature is:

```{r}
quantile(full_mzw)
```

And the full rt width of all chromatographic peaks per feature:

```{r}
quantile(full_rtw)
```

```{r, fig.cap = "Features' median retention time against rt widths (of all chrom peaks) and features' median m/z against m/z width (of all peaks)."}
par(mfrow = c(1, 2))
plot(featureDefinitions(chris)$rtmed, full_rtw, xlab = "rt",
     ylab = "rt width", main = "full chrom peak range", pch = 21,
     col = "#00000040", bg = "#00000020")
grid()
plot(featureDefinitions(chris)$mzmed, full_mzw, xlab = "m/z",
     ylab = "m/z width", main = "full chrom peak range", pch = 21,
     col = "#00000040", bg = "#00000020")
grid()
```

The full m/z range of all chromatographic peaks per feature is (not
unexpectedly) much larger than the m/z range for the apex positions. Still, the
magnitude of this m/z range is quite high.

To evaluate the performance of the correspondence analysis we first identify
features for each of the standards, extract their EIC and plot them.

```{r eics_after_correspondence_standards}
#' Identify features for standards, extract and plot them. The difference
#' here to the next code block (in which EICs are extracted using m/z and
#' rt ranges) is that here we are specifically matching features to standards
#' and are extracting the EIC for these features only (with
#' featureChromatograms)
#'
#' match standards to identified features.
fts <- featureDefinitions(chris)
fts$feature_id <- rownames(fts)
standards_all_match <- matchValues(
    query = standards_chris_pos, target = fts,
    mzColname = c("mz", "mzmed"), rtColname = c("RT", "rtmed" ),
    param = MzRtParam(ppm = 10, tolerance = 0.01, toleranceRt = 7))

#' Clean up:
#' - remove all standards without match
standards_all_match <- standards_all_match[whichQuery(standards_all_match)]
#' - select for each standard the *best* match
standards_all_match <- filterMatches(
    standards_all_match, SingleMatchParam(duplicates = "closest"))

#' Extract EICs for these features.
standards_all_eic <- featureChromatograms(
    chris, features = standards_all_match$target_feature_id,
    expandRt = 2, chunkSize = NR_CORES)

#' Plot the EICs
dr <- file.path(IMAGE_PATH, "EIC_standards/full/after_correspondence/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_along(standards_all_match)) {
    png(paste0(dr, "EIC_", standards_all_match$abbreviation[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    eic <- standards_all_eic[i, ]
    plotChromPeakDensity(
        eic, main = standards_all_match$name[i],
        col = paste0(col_batches, 80),
        peakCol = paste0(col_batches[chromPeaks(eic)[, "sample"]], 80),
        peakBg = paste0(col_batches[chromPeaks(eic)[, "sample"]], 20),
        peakPch = 21, simulate = FALSE)
    grid()
    legend("topright",
           col = col_batch,
           legend = names(col_batch),
           lty = 1)
    legend("topleft",
           legend = c(paste0("m/z: ", format(fData(eic)$mzmin, 4),
                             " - ", format(fData(eic)$mzmax, 4)),
                      paste0("feature: ", rownames(featureDefinitions(eic)))))
    abline(v = standards_all_match$RT[i], col = "red", lty = 3)
    dev.off()
}

```


## Gap filling

Process to try to rescue some (pre-)selected peaks that are only detected in a
subset of samples.

```{r, echo=FALSE}
#' Number of missing values
print('nr of missing values before gap filling:')
sum(is.na(featureValues(chris)))
```

We can see quite a large amount of NA values in our data set.

```{r gap_filling, eval = !file.exists("chris_after_gap_filling.RData")}
chris <- fillChromPeaks(chris, param = ChromPeakAreaParam(), chunkSize = NR_CORES)
save(chris, file = paste0(RDATA_PATH, "chris_after_gap_filling.RData"))
```

```{r eval = file.exists("chris_after_gap_filling.RData")}
load(paste0(RDATA_PATH, "chris_after_gap_filling.RData"))
```

```{r summary gap filling}
#' How many missing values after
print('nr of missing values after gap filling:')
sum(is.na(featureValues(chris)))
```

With `fillChromPeaks` we could thus rescue signal for all but `r
sum(is.na(featureValues(chris)))` features.

Another way to confirm gap-filling rescued signals, use QC sample signals as
basis

```{r Detected vs filled signal}
#' Get only detected signal
vals_detect <- featureValues(chris, filled = FALSE)[, pool_index]

#' Get detected and filled-in signal
vals_filled <- featureValues(chris)[, pool_index]

#' Replace detected signal with NA
vals_filled[!is.na(vals_detect)] <- NA

#' Identify features with at least one filled peak
has_filled <- is.na(rowSums(vals_detect))

#' Calculate row averages
avg_detect <- rowMeans(vals_detect, na.rm = TRUE)
avg_filled <- rowMeans(vals_filled, na.rm = TRUE)

#' Restrict to features with at least one filled peak
avg_detect <- avg_detect[has_filled]
avg_filled <- avg_filled[has_filled]

#' calc R2 using linear regression
#' want to perform regression from avg_detect --> avg_filled
m <- lm(log2(avg_filled) ~ log2(avg_detect))
a <- as.numeric(format(round(coef(m)[2], digits=3),nsmall=3)) #rico
b <- as.numeric(format(round(coef(m)[1], digits=3),nsmall=3)) #intercept
r2 <- format(round(summary(m)$r.squared, digits=3),nsmall=3) #model minimize the squared error, R2 is the total % variance accounted for by the model.
equation <- paste0("y = ", a, " . x + ", b)

#' plot the values against each other (in log2 scale)
plot(log2(avg_detect), log2(avg_filled),
     xlim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),
     ylim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),
     pch = 21, bg = "#00000080")
grid()
abline(0, 1)
text(3, 23 , paste0(equation, ', R2 = ', r2), pos = 4)

```

Then calculate statistics on these values. below we fit a linear regression line
to the data and summarize its results

```{r summary lm Detected vs filled signal}
#' fit a linear regression line to the data
l <- lm(log2(avg_filled) ~ log2(avg_detect))
summary(l)
```

## Removing features detected in blank

```{r eval = file.exists("chris_after_gap_filling.RData")}
load(paste0(RDATA_PATH, "chris_after_gap_filling.RData"))
```

```{r rm_feats_detected_in_blanks}
#' remove features detected in blank samples
blank_index <- sampleData(chris)$sample_type == "Blank"
sample_index <- sampleData(chris)$sample_type != "Blank"
fts <- featureValues(chris)
cont_vec <- vector(length = length(featureDefinitions(chris)))

for (i in seq_len(nrow(fts))) {
    cont_vec[i] <- mean(fts[i, blank_index], na.rm = TRUE) > 0.5 * mean(fts[i, sample_index], na.rm = TRUE)
    }

#' flagged features
print('flagged samples:')
sum(cont_vec, na.rm = TRUE)

#' add column "possible_cont" to the feature definitions table
featureDefinitions(chris)$possible_cont <- cont_vec

```

# Next steps

separate blanks from others

```{r sep blanks and bio samples}
blank_sample <- chris[blank_index, keepAdjustedRtime = TRUE,
                      keepFeatures = TRUE]
chris <- chris[!blank_index, keepAdjustedRtime = TRUE,
               keepFeatures = TRUE]

save(blank_sample, file = paste0(RDATA_PATH, "blank_chris.RData"))
save(chris, file = paste0(RDATA_PATH, "samples_chris.RData"))
```

# Summarized experiment

```{r SummarizedExperiment}
#' Extract results as a SummarizedExperiment
res <- quantify(chris, method = "sum", filled = FALSE)
assays(res)$raw_filled <- featureValues(chris, method = "sum", filled = TRUE)
res
save(res, file = paste0(RDATA_PATH, "SumExp_chris.RData"))

# also for blanks (if present)
if (nrow(sampleData(blank_sample)) >= 1) {
    res_blank <- quantify(blank_sample, method = "sum", filled = FALSE)
    assays(res_blank)$raw_filled <- featureValues(blank_sample, method = "sum",
                                                  filled = TRUE )
    save(res_blank, file = paste0(RDATA_PATH, "SumExp_chris_blank.RData"))
    }

```



# Session information

```{r}
sessionInfo()
```

# References

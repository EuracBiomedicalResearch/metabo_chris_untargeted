---
title: "CHRIS_normalization_pos"
author: "Marilyn De Graeve, Philippine Louail, Johannes Rainer"
affiliation: "Eurac Research, Bolzano, Italy"
date: "2024-06-24"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
    code_folding: hide
editor_options:
  markdown:
    wrap: 72
bibliography: references.bib
---

**Modified**: `r file.info("CHRIS_preprocessing_pos.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r style, message = FALSE, echo = FALSE, warning = FALSE, results = "asis"}
library("BiocStyle")
library("knitr")
library("rmarkdown")
opts_chunk$set(message = FALSE, error = FALSE, warning = FALSE,
               cache = FALSE, fig.width = 7, fig.height = 7, dev = "png",
               dpi = 300)
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now, units = "secs")
      # return a character string to show the time
      paste("    Time for this code chunk to run:", round(res,
        2), "seconds")
    }
  }
}))

```

# Introduction

During this workflow, the normalization of the untargeted metabolomics data of
the Cooperative Health Research in South Tirol (CHRIS) study is performed. For a
description of the study, methods used for the collection, handling and
aqcuisition of the liquid chromatography-mass spectrometry (LC-MS) samples,
please see [@verri_hernandes_age_2022]. Samples are acquired in both positive
and negative ionization mode, for which the normalization of the positive (pos)
mode will be performed in this Rmarkdown document.

# Setup

## Directories

```{r directories, echo = FALSE}
#' General settings
filename <- "CHRIS_normalization_pos"

#' Path to save images to; remove if exists.
IMAGE_PATH <- paste0("images/", filename, "/")
dir.create(IMAGE_PATH, recursive = TRUE)

#' Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
dir.create(RDATA_PATH, recursive = TRUE, showWarnings = FALSE)

#' Path to the data
#SDATA_PATH <- '/home/mdegraeve/Documents/Files/Work_Eurac/Data/CHRIS' #FINDME!
SDATA_PATH <- "data"
#DATA_PATH <- "."
DATA_PATH <- "data"

```

## Packages

```{r packages, message=FALSE}
library(MsExperiment)
library(RSQLite)
library(xcms)
library(Spectra)
library(RColorBrewer)
library(pander)
library(readxl)
library(reshape2)
library(MetaboAnnotation)
library(MetaboCoreUtils)
library(MsBackendSql)
#library(CompMetaboTools)
library(SummarizedExperiment)
library(ggfortify)
library(ggplot2)

```

## Computation

```{r parallel_processing_setup, message=FALSE}
#' Set up parallel processing using multiple cores get the number of
#' cpus allocated by queueing system or fall back to 7
NR_CORES <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 8)) - 1L
if (.Platform$OS.type == "unix") {
    register(MulticoreParam(NR_CORES))
} else {
    register(bpstart(SnowParam(NR_CORES)))
}

```

## functions

```{r plot-functions}
#' fast computational PCA score plotting functions
#' https://ggplot2.tidyverse.org/reference/scale_shape.html
shapes <- c(21, 24, 22, 23) #, 16, 17, 15, 18, 1, 2, 0, 5, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 19, 20) #25 available, pick coloreble ones
shapes <- rep(shapes,100)

theme_customgridbox<- function () {
  theme(legend.position = "right",
  legend.title = element_text(face="bold",size=18),
  legend.text = element_text(size=18),
  legend.key = element_rect(fill=NA),
  axis.title = element_text(size=16),
  axis.text = element_text(size=16,colour="black"),
  axis.ticks = element_line(colour = "black"),
  plot.title = element_text(face="bold",size=18,hjust=0.5),
  panel.background = element_rect(fill=NA),
  panel.grid.major = element_line(colour="grey80"),
  panel.border = element_rect(fill=NA,size=1))
}
plot_pca <- function(scores, comp, col_palette) {
  ggplot(data = scores, aes(x = PC1, y = PC2), label = rownames(scores)) +
      geom_hline(yintercept = 0, colour = "gray65") +
      geom_vline(xintercept = 0, colour = "gray65") +
      geom_point(aes(fill = comp, shape = comp), color = 'black', size = 1) +
	    theme_customgridbox() +
      ggtitle("PCA score plot") +
      scale_shape_manual(values = shapes) +
      scale_color_discrete(col_palette) +
      guides(colour ='none', fill = 'none', shape = 'none')      
}
plot_multiboxplot <- function(df) {
  ggplot(df, aes(x = variable, y = value, fill = col)) +
      geom_boxplot() +
      #geom_jitter(alpha = 0.5, color= "gray65", height = 0, width = 0.3, size = 0.1) +
      labs(title = "Before normalization",
           y = "CV distribution of QC2",
           x = "Batch") +
      scale_color_manual(col) +
      theme_customgridbox() +
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 7),
            legend.position="none")
}

#' testing
#colnames(pca_res$x)[1:2]
#pca_res$x[1:5,1:5]
#scores <- as.data.frame(pca_res$x)[,1:2]
#comp <- res$injection_index
#comp[1:10]
#col_palette <- col_injection_index


#' Impute missing values using uniform distribution
na.unidis <- function(z) {
    na <- is.na(z)
    if (any(na)) {
        min = min(z, na.rm = TRUE)
        z[na] <- runif(sum(na), min = min/2, max = min)
    }
    z
}

#' calculate correlations (below 2nd version w 3/4)
cor_fun <- function(row) {
    if (sum(!is.na(row)) >= 6)
        cor(row, tmp$injection_index, method = "spearman",
            use = "pairwise.complete.obs")
    else NA_real_
}
cor_fun_inj <- function(row, i_d) {
    if (sum(!is.na(row)) >= 3*(length(row))/4) ## 3/4 detection rate
        cor(row, i_d, method = "spearman",
            use = "pairwise.complete.obs")
    else NA_real_
}

#' anova for fstats
aov_fun <- function(row, i_d) {
    if (sum(!is.na(row)) >= 55){
        tmp <- data.frame(y = row, batch_id = i_d)
        aov(y ~ batch_id, data = tmp)
    }
}

```

# Load data

```{r load Rdata}
#' Load preprocessing results
load(file.path(SDATA_PATH, "SumExp_chris.RData")) #res is object
load(file.path(SDATA_PATH, "SumExp_chris_blank.RData"))
load(file.path(SDATA_PATH, "samples_chris.RData"))
load(file.path(SDATA_PATH, "blank_chris.RData"))

## create a separate object for Pool_Dil and Pool_IS_dil because they affect PCA visualisaiton
pool_dil_idx <- res$sample_type == "Pool_Dil"
pool_dil <- res[, pool_dil_idx]
res <- res[, !pool_dil_idx]
pool_dil_is_idx <-res$sample_type == "Pool_IS_Dil"
pool_dil_is <- res[, pool_dil_is_idx]
res <- res[, !pool_dil_is_idx]

#save(pool_dil, file = file.path(RDATA_PATH, "SumExp_chris_pool_dil.RData"))
#save(pool_dil_is, file = file.path(RDATA_PATH, "SumExp_chris_pool_dil_is.RData"))

## check all good, OK
#res$sample_type
#unique(res$batch_id)

#' Define colors for the groups.
#' Sample type
col_phenotype <- brewer.pal(5, "Accent")[c(1, 5)]
names(col_phenotype) <- c("Study", "Pool")

col_sample <- col_phenotype[res$sample_type]

#' Batches
#' Define a unique color for each batch.
col_batch_id <- rainbow(length(unique(res$batch_id)))
names(col_batch_id) <- unique(res$batch_id)

col_batches <- col_batch_id[res$batch_id]

#' Injection index
col_injection_index <- heat.colors(length(unique(res$injection_index)))


#' Create an assay with the filled and imputed value.
tmp <- apply(assay(res, "raw_filled"), MARGIN = 1, na.unidis)
assays(res)$raw_filled_imputed <- t(tmp)

#' not used, skip
#smf <- do.call(.mztab_small_molecule_feature,
#                             c(list(object = object,
#                                    opt_columns = param@optionalFeatureColumns),
#                                    param@dots))

```

# Before normalization

## Unsupervised PCA

```{r PCA-before-norm, fig.path = IMAGE_PATH}
# With imputation
vals <- assay(res, "raw_filled_imputed") |>
    log2() |>
    t() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

#load(file.path(RDATA_PATH, "pca_res_before.RData"))
#save(pca_res, file = file.path(RDATA_PATH, "pca_res_before.RData"))

#' sample type
p <- plot_pca(as.data.frame(pca_res$x), res$sample_type, col_phenotype)
plot(p)

#' batches
p <- plot_pca(as.data.frame(pca_res$x), res$batch_id, col_batch_id)
plot(p)

#' injection index
p <- plot_pca(as.data.frame(pca_res$x), as.factor(res$injection_index), col_injection_index)
plot(p)

```
- PC1 batches left (scattered) and blank samples spread to bottom right
- PC2 batches
- pool samples central whitin each batch between the study samples
- injection order central or for some batches see drift downward diagonal (see top right batches)


## Intensity evaluation

Counts of non missing values and feature abundance distribution

```{r counts-before-norm, fig.path = IMAGE_PATH, fig.height=7, fig.width=8, include=TRUE}
layout(mat = matrix(1:3, ncol = 1), height = c(0.2, 0.2, 0.8))

par(mar = c(0.2, 4.5, 0.2, 3))
barplot(apply(assay(res, "raw"), MARGIN = 2, function(x) sum(!is.na(x))),
        col = col_sample, ylab = "features raw data", xaxt = "n", space = 0.012,
        border = NA)
barplot(apply(assay(res, "raw_filled"), MARGIN = 2, function(x) sum(!is.na(x))),
        col = col_sample, ylab = "features filled data", xaxt = "n",
        space = 0.012, border = NA)
boxplot(log2(assay(res, "raw_filled")), xaxt = "n",
        ylab = expression(log[2]~abundance~filled~data),
        col = col_sample, outline=FALSE, medlty = "blank", border = col_sample,
        boxwex = 0.99 )
points(colMedians(log2(assay(res, "raw_filled")), na.rm = TRUE), type = "l",
       pch = 16)
grid(nx = NA, ny = NULL)
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.8,  bty = "n")
```

## RLA

Calculate and plot the relative log abundances (RLA) colored by samples type.

```{r rla-plot-before-norm raw and filled, fig.path = IMAGE_PATH, fig.width= 8, fig.cap = "RLA plot for the raw data and filled data. Note: outliers are not drawn."}
par(mfrow = c(1, 1), mar = c(0.2, 4.5, 2.5, 3))
boxplot(rowRla(assay(res, "raw_filled"), group = res$sample_type),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        #border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "Filled in data", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
legend("bottomright", col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.8,  bty = "n")
```

Colored by batches.

```{r rla-plot raw and filled-beforenorm, fig.path = IMAGE_PATH, fig.width = 8,  fig.cap = "RLA plot for the raw data and filled data. Note: outliers are not drawn."}
par(mfrow = c(1, 1), mar = c(0.2, 4.5, 2.5, 3))
boxplot(rowRla(assay(res, "raw_filled"), group = res$batch_id),
        cex = 0.5, pch = 16,
        col = col_batches, ylab = "RLA",
        #border = paste0(col_batches, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "Filled in data", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
legend("bottom", col = col_batch_id,
       legend = names(col_batch_id), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.8,  bty = "n")
```

This already give us an idea of the variation within batch.


# Between sample - median scaling

```{r median-scaling}
#' Compute median and generate normalization factor
mdns <- apply(assay(res, "raw_filled"), MARGIN = 2,
              median, na.rm = TRUE )
nf_mdn <- mdns / median(mdns)

#' divide dataset by median of median and create a new assay.
assays(res)$norm <- sweep(assay(res, "raw_filled"), MARGIN = 2, nf_mdn, '/')
assays(res)$norm_imputed <- sweep(assay(res, "raw_filled_imputed"), MARGIN = 2,
                                  nf_mdn, '/')
```

## Evaluation

### coef of variation of QC samples

```{r CV-after_MS, include=TRUE, results = "asis"}
index_QC <- res$sample_type == "Pool"

QC <- cbind(
    CV_Raw = rowRsd(assay(res, "raw_filled")[, index_QC], na.rm = TRUE),
    CV_Median_scaled = rowRsd(assay(res, "norm")[, index_QC], na.rm = TRUE)
    )

#' Quantile
QC_df <- data.frame(raw = quantile(QC[, "CV_Raw"], na.rm = TRUE),
                    MRM = quantile(QC[, "CV_Median_scaled"], na.rm = TRUE)
                    )
cpt <- paste0("Distribution of CV values across QC samples for the raw ",
              "and between-sample normalized data.")
pandoc.table(QC_df, style = "rmarkdown", caption = cpt)
```

### Coef of variation of IS

```{r CV-is-after_MS, include=TRUE, results = "asis"}
intern_standard$CV_Raw <- rowRsd(
    assay(res, "raw_filled")[intern_standard$feature_id, ], na.rm = TRUE)
intern_standard$CV_Median_scaled <- rowRsd(
    assay(res, "norm")[intern_standard$feature_id, ], na.rm = TRUE)

cpt <- paste("Internal standards with detected and assigned features coefficient
             of variation before and after different method of normalization.")
pandoc.table(intern_standard[, c("abbreviation", "CV_Raw", "CV_Median_scaled")],
             style = "rmarkdown", caption = cpt)
```

IS mix NOT evaluated for the full dataset.


#### RLA

```{r rla-plots evaluate norm method, include=TRUE, fig.path = IMAGE_PATH, fig.cap = "RLA plot for the raw data and different sample normalization method. Note: outliers are not drawn.", fig.width = 8, fig.height = 7}
par(mfrow = c(2, 1), mar = c(0.2, 2, 3, 3))

boxplot(rowRla(assay(res, "raw_filled"), group = res$sample_type),
        cex = 0.5, pch = 16, col = col_sample, ylab = "RLA",
        #border = paste0(col_sample, 40), notch = TRUE, cex.main = 1,
        outline = FALSE, xaxt = "n", main = "Raw data", boxwex = 1)
grid(nx = NA, ny = NULL)
legend("topright", inset = c(0, -0.18), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 2,
       cex = 0.7)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(rowRla(assay(res, "norm"), group = res$sample_type),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        #border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "Median scaled", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
```

#### Boxplot of abundances

```{r boxplots evaluate norm method, include=TRUE, fig.path = IMAGE_PATH, fig.cap = "Boxplots of signal distributions for the raw data and different sample normalization method. Note: outliers are not drawn.", fig.width = 8, fig.height = 7}
par(mfrow = c(2, 1), mar = c(0.5, 4.5, 3, 3))

boxplot(log2(assay(res, "raw_filled")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        #border = paste0(col_sample, 40), notch = TRUE, cex.main = 1,
        outline = FALSE, xaxt = "n", main = "Raw data", boxwex = 1)
grid(nx = NA, ny = NULL)
legend("topleft", inset = c(0, -0.18), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 2,
       cex = 0.7)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(log2(assay(res, "norm")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        #border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "Median scaled", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
```

## PCA

```{r pca-after-MS, fig.path = IMAGE_PATH, fig.height=7, fig.width=8}
# With imputation
vals <- assay(res, "norm_imputed") |>
    log2() |>
    t() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

#save(pca_res, file = file.path(RDATA_PATH, "pca_after_MS.RData"))  #FINDME

#' sample type
p <- plot_pca(as.data.frame(pca_res$x), res$sample_type, col_phenotype)
plot(p)

#' batches
p <- plot_pca(as.data.frame(pca_res$x), res$batch_id, col_batch_id)
plot(p)

#' injection index
p <- plot_pca(as.data.frame(pca_res$x), as.factor(res$injection_index), col_injection_index)
plot(p)


```

```{r eval = !file.exists(paste0(RDATA_PATH, "SumExp_chris_norm_MS.RData"))}
save(res, file = file.path(RDATA_PATH, "SumExp_chris_norm_MS.RData"))

```

OK! already much better, most batches get together. but also some with to right
side of PC1. these represent the last run ~10-20 batches.  In PC2 also most
batches cluster together but ~5-10 batches that are together to top of PC2.  To
further improve, do lm using batch id.






# Within batches normalization

```{r load-ms, eval = file.exists(paste0(RDATA_PATH, "SumExp_chris_norm_MS.RData"))}
load(file.path(RDATA_PATH, "SumExp_chris_norm_MS.RData"))

#' Redefine colors for the groups.
#' Sample type
col_phenotype <- brewer.pal(5, "Accent")[c(1, 5)]
names(col_phenotype) <- c("Study", "Pool")

col_sample <- col_phenotype[res$sample_type]

#' Batches
#' Define a unique color for each batch.
col_batch_id <- rainbow(length(unique(res$batch_id)))
names(col_batch_id) <- unique(res$batch_id)

col_batches <- col_batch_id[res$batch_id]

#' Injection index
col_injection_index <- heat.colors(length(unique(res$injection_index)))

```

## evaluate correlation to injection index

```{r correlation-inj-idx-before, fig.path = IMAGE_PATH, fig.height=4, fig.width=9}
#' Define a function to calculate the correlation per batches
#test for one batch
pool_index <- res$sample_type == "Pool"
res_qc <- res[, pool_index]
batch_id <- unique(res_qc$batch_id)

dr <- file.path(DATA_PATH, "normalisation/within_batch/")

#' testing: i <- 'BATCH0001'
for (i in batch_id) {
    tmp <- res_qc[, res_qc$batch_id == i]
    cor_res <- apply(assay(tmp, "norm"), MARGIN = 1, FUN = cor_fun)
    par(mfrow = c(1,2), mar = c(2, 2, 2, 2))
    plot(sort(cor_res), col = col_batch_id[i], main = paste0("QC samples ", i), ylab = "rho",
     xlab = "rank")
    rect(par("usr")[1], -0.2, par("usr")[2], 0.2, col = "#FFCCCC40", border = NA)
    hist(cor_res)
}

```

Done. See images in folder for each batch.


## fit linear model with inj index

fit feature-wise linear model (y ~ inj_idx) to the (log2 transformed) abundance
data of the QC samples within each batch and compare the slopes for each feature
between the batches.

Here I build a loop to fit and adjust linear model to each feature to determine
the relationship between the injection index and abundance within each batch.
Some info because the code is probably confusing:

- the linear model is fitted only for features that are present in at least 8
out of 10 of the QC samples.

- out of these features only the ones where the fit has a p value of less than
  0.05 will be adjusted.

- this loop also produces some interesting plots for each batch:
    - a plot and histogram showing the distribution of the correlation of each
    features with the injection index
    - distribution of p-value vs the coefficient of the linear model (slope)
    - plots of the highest significant and highest non- significant slope
    - a final figure that shows the before and after of the correlation of each
    features with injection index before and after the adjusted to the linear
    model. and this is plotted for both QC samples and study samples.

```{r loop-inj-idx-correction}
#' subsetting for loop
pool_index <- res$sample_type == "Pool"
study_index <- res$sample_type == "Study"
res_qc <- res[, pool_index]
res_study <- res[, study_index]

batch_id <- unique(res_qc$batch_id)


#' duplicate norm object to replace with new values in loop
assay(res, "norm_wb") <- assay(res, "norm")

#' big loop
#' test i <- 'BATCH0009'
for (i in batch_id) {
    try({ #some batches have no p.value but F column FIND_ME!!!
    ## extract for one batch
    tmp_qc <- res_qc[, res_qc$batch_id == i]
    tmp_sample <- res_study[, res_study$batch_id == i]
    tmp_full <- res[, res$batch_id == i]

    dr_b <- paste0(IMAGE_PATH, i, "/")
    dir.create(dr_b, recursive = TRUE, showWarnings = FALSE)

    ## evaluate the need for adjustment by checking correlation of abundance
    ## with injection index
    cor_before <- apply(assay(tmp_qc, "norm"), MARGIN = 1,
                        FUN = cor_fun_inj, i_d = tmp_qc$injection_index)
    ## plot
    png(paste0(dr_b, "cor_before.png"), width = 12, height = 8, units = "cm",
        res = 600, pointsize = 4)
    par(mfrow = c(1,2), mar = c(2, 2, 2, 2))
    plot(sort(cor_before), col = col_batch_id[i], main = paste0("QC samples ", i),
         ylab = "rho", xlab = "rank")
    rect(par("usr")[1], -0.2, par("usr")[2], 0.2, col = "#FFCCCC40",
         border = NA)
    hist(cor_res)
    dev.off()

    ## fit linear model on QC samples
    qc_lm <- fit_lm(y ~ injection_index,
                data = data.frame(injection_index = tmp_qc$injection_index),
                y = log2(assay(tmp_qc, "norm")),
                minVals = 8) ## 80% detection rate (10 QC samples per batches)

    ## get summary
    qc_lm_summary <- lapply(qc_lm, function(z) {
        if (length(z) > 1) {
        s <- summary(z)
        c(slope = coefficients(s)[2, "Estimate"],
          p.value = coefficients(s)[2, 4],
          adj.r.squared = s$adj.r.squared)
        } else c(slope = NA_real_, F = NA_real_,
             adj.r.squared = NA_real_)
        }) |> do.call(what = rbind)
    head(qc_lm_summary)

    ## plot p value vs coeff
    png(paste0(dr_b, "volcano.png"), width = 12, height = 8, units = "cm",
        res = 600, pointsize = 4)
    plot(qc_lm_summary[, "slope"], -log10(qc_lm_summary[, "p.value"]),
     xlab = "injection order dependency", ylab = expression(-log[10](p~value)),
     pch = 21, col = "#00000080", bg = "#00000040")
    grid()
    abline(h = -log10(0.05))
    dev.off()

    ## plot highest non-significant slope
    png(paste0(dr_b, "high_slope_non_significant.png"), width = 12, height = 8, units = "cm",
        res = 600, pointsize = 4)
    sign <- qc_lm_summary[qc_lm_summary[, "p.value"] > 0.05, ]
    idx <- which.max(sign[, "slope"])
    plot(x = tmp_full$injection_index, y = log2(assay(tmp_full, "norm")[idx, ]),
         xlab = "injection_index", ylab = expression(log[2]~abundance))
    points(x = tmp_qc$injection_index,
           y = log2(assay(tmp_qc, "norm")[idx, ]), pch = 16, col = "red")
    grid()
    try(abline(qc_lm[[idx]])) #TODO error since is NA
    dev.off()

    ## plot highest significant slope
    png(paste0(dr_b, "high_slope_significant.png"), width = 12, height = 8, units = "cm",
        res = 600, pointsize = 4)
    sign <- qc_lm_summary[qc_lm_summary[, "p.value"] < 0.05, ]
    idx <- which.max(sign[, "slope"])
    plot(x = tmp_full$injection_index, y = log2(assay(tmp_full, "norm")[idx, ]),
         xlab = "injection_index", ylab = expression(log[2]~abundance))
    points(x = tmp_qc$injection_index,
           y = log2(assay(tmp_qc, "norm")[idx, ]), pch = 16, col = "red")
    grid()
    abline(qc_lm[[idx]])
    dev.off()

    ## number that would not be adjusted
    print(paste0(length(qc_lm[qc_lm_summary[, "p.value"] < 0.05]),
                 " features are going to be adjusted for ", i))
    qc_lm[qc_lm_summary[, "p.value"] > 0.05] <- NA

    ## adjust
    vals_adj <- adjust_lm(log2(assay(tmp_full, "norm")), data = data.frame(injection_index = tmp_full$injection_index), lm = qc_lm)
    vals_adj <- 2^vals_adj
    vals_adj <- as.data.frame(vals_adj)

    ## Compare correlation before and after: qc samples
    val_qc <- vals_adj[, tmp_full$sample_type == "Pool"]
    cor_after_qc <- apply(val_qc, MARGIN = 1, FUN = cor_fun_inj, i_d = tmp_qc$injection_index)

    ## Compare correlation before and after: study samples
    cor_before_study<- apply(assay(tmp_sample, "norm"), MARGIN = 1, FUN = cor_fun_inj, i_d = tmp_sample$injection_index)
    val_study <- vals_adj[, tmp_full$sample_type == "Study"]
    cor_after_study<- apply(val_study, MARGIN = 1, FUN = cor_fun_inj, i_d = tmp_sample$injection_index)

    ## plot all together
    png(paste0(dr_b, "cor_after.png"), width = 15, height = 8, units = "cm",
        res = 600, pointsize = 4)
    par(mfrow = c(1, 2))
    plot(sort(cor_before), col = "black",
         main = paste0("QC samples ", i, " before (black) and after (color) norm"),
         ylab = "rho", xlab = "rank")
    points(sort(cor_after_qc), col = col_batch_id[i])
    rect(par("usr")[1], -0.2, par("usr")[2], 0.2, col = "#FFCCCC40",
         border = NA)
    plot(sort(cor_before_study), col = "black",
         main = paste0("Study samples ", i, " before (black) and after (red) norm"),
         ylab = "rho", xlab = "rank")
    rect(par("usr")[1], -0.2, par("usr")[2], 0.2, col = "#FFCCCC40",
         border = NA)
    points(sort(cor_after_study), col = col_batch_id[i])
    dev.off()

    ##replace in res object
    assay(res, "norm_wb")[row.names(vals_adj), colnames(vals_adj)] <- as.matrix(vals_adj)
    })
    }

#' impute assay
tmp <- assay(res, "norm_wb")
tmp <- apply(tmp, MARGIN = 1, na.unidis)
assays(res)$norm_wb_imputed <- t(tmp)

```

## PCA

```{r pca-after-wb, fig.path = IMAGE_PATH, fig.height=7, fig.width=18}
# With imputation
vals <- assay(res, "norm_wb_imputed") |>
    log2() |>
    t() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

#save(pca_res, file = file.path(RDATA_PATH, "pca_after-wb.RData"))  #FINDME

#' sample type
p <- plot_pca(as.data.frame(pca_res$x), res$sample_type, col_phenotype)
plot(p)

#' batches
p <- plot_pca(as.data.frame(pca_res$x), res$batch_id, col_batch_id)
plot(p)

#' injection index
p <- plot_pca(as.data.frame(pca_res$x), as.factor(res$injection_index), col_injection_index)
plot(p)

```

PCA look the same as before but i check the assay has different values. So I
don't think it is an error in the code and more that this was of adjusting for
injection index does not affect results distribution that much...

```{r eval = !file.exists(paste0(RDATA_PATH, "SumExp_chris_after_wb.RData"))}
save(res, file = file.path(RDATA_PATH, "SumExp_chris_after_wb.RData"))

```





# Between batches normalization

Eliminate batch-specific effects by considering abundance differences in QC
samples across various batches. Ensure that for each feature, the QC values are
consistent and normalize accordingly. This approach is beneficial for datasets
measured over extended periods or diverse locations.

```{r load-wb, eval = file.exists(paste0(RDATA_PATH, "SumExp_chris_after_wb.RData"))}
load(file.path(RDATA_PATH, "SumExp_chris_after_wb.RData"))

#' Redefine colors for the groups.
#' Sample type
col_phenotype <- brewer.pal(5, "Accent")[c(1, 5)]
names(col_phenotype) <- c("Study", "Pool")

col_sample <- col_phenotype[res$sample_type]

#' Batches
#' Define a unique color for each batch.
col_batch_id <- rainbow(length(unique(res$batch_id)))
names(col_batch_id) <- unique(res$batch_id)

col_batches <- col_batch_id[res$batch_id]

#' Injection index
col_injection_index <- heat.colors(length(unique(res$injection_index)))

```

## evaluate relationship between batches

```{r fstat-before, fig.path = IMAGE_PATH, fig.height=6, fig.width=8}
#' Define a function to calculate the correlation per batches
#test for one batch
pool_index <- res$sample_type == "Pool"
res_qc <- res[, pool_index]

#' anova for calc f
aov_before_qc <- apply(log2(assay(res_qc, "norm_wb")), MARGIN = 1, FUN = aov_fun,
                       i_d = res_qc$batch_id, simplify = FALSE)

# get f value for each feature, super annoying the result format is weird
vec_P_before_qc <- vector(length = length(aov_before_qc))
vec_F_before_qc <- vector(length = length(aov_before_qc))


for (i in seq_len(length(aov_before_qc))) {
    if(!is.null(aov_before_qc[[i]])) {
        df <- summary(aov_before_qc[[i]])[[1]]
        vec_F_before_qc[i] <- df["batch_id", "F value"]
        vec_P_before_qc[i] <- df["batch_id", "Pr(>F)"]
    }

}


par(mfrow = c(1,2), mar = c(2, 2, 2, 2))
plot(sort(vec_F_before_qc), col= "black", main = "QC sample betweeen batch anova F value")
abline(h = 1)
hist(vec_P_before_qc, breaks = 50)

sum(vec_P_before_qc < 0.05)
sum(vec_F_before_qc >1)

```

almost all (19400 for F and 19401 for P out of total 19401!)of the features show
significance The conclusion is that we need ot adjust everything and hopefully
it fixes the F-statistics a bit


## fit lm and adjust with batch id

```{r lm-bb, fig.path = IMAGE_PATH}
## fit linear model on QC samples
qc_lm <- fit_lm(y ~ batch_id,
            data = data.frame(batch_id = res_qc$batch_id),
            y = log2(assay(res_qc, "norm_wb")),
            minVals = 50) ## 80% detection rate

# Need to remove features that have less than 5 non-missing values in one batch
res_qc <- res[, pool_index]
batch_id <- unique(res_qc$batch_id)
vec_remove <- integer(0)

for (i in batch_id) {
    tmp_qc <- res_qc[,res_qc$batch_id == i]
    tmp_flag <- apply(assay(tmp_qc, "norm_wb"), MARGIN = 1, function(row){sum(!is.na(row)) < 5})
    tmp_flag <- which(tmp_flag)
    vec_remove <- c(vec_remove, tmp_flag)
}

# get unique features
vec_remove <- unique(vec_remove)

# replace by NA
qc_lm[vec_remove] <- NA

## get summary
qc_lm_summary <- lapply(qc_lm, function(z) {
    if (length(z) > 1) {
    s <- summary(z)
    c(slope = coefficients(s)[2, "Estimate"],
      p.value = coefficients(s)[2, 4],
      adj.r.squared = s$adj.r.squared)
    } else c(slope = NA_real_, F = NA_real_,
         adj.r.squared = NA_real_)
    }) |> do.call(what = rbind)
head(qc_lm_summary)

try({ #some batches have no p.value but F column FIND_ME!!!
    ## plot p value vs coeff
    plot(qc_lm_summary[, "slope"], -log10(qc_lm_summary[, "p.value"]),
     xlab = "batch mid order dependency", ylab = expression(-log[10](p~value)),
     pch = 21, col = "#00000080", bg = "#00000040")
    grid()
    abline(h = -log10(0.05))

    ## plot highest non-significant slope
    sign <- qc_lm_summary[qc_lm_summary[, "p.value"] > 0.05, ]
    idx <- which.max(sign[, "slope"])
    plot(x = factor(res$batch_id), y = log2(assay(res, "norm_wb")[idx, ]),
         xlab = "batch_id", ylab = expression(log[2]~abundance))
    points(x = factor(res_qc$batch_id),
           y = log2(assay(res_qc, "norm_wb")[idx, ]), pch = 16, col = "red")
    grid()

    ## plot highest significant slope
    sign <- qc_lm_summary[qc_lm_summary[, "p.value"] < 0.05, ]
    idx <- which.max(sign[, "slope"])
    plot(x = factor(res$batch_id), y = log2(assay(res, "norm_wb")[idx, ]),
         xlab = "batch_id", ylab = expression(log[2]~abundance))
    points(x = factor(res_qc$batch_id),
           y = log2(assay(res_qc, "norm_wb")[idx, ]), pch = 16, col = "red")
    grid()
})

## adjust
vals_adj <- adjust_lm(log2(assay(res, "norm_wb")), data = data.frame(batch_id = res$batch_id), lm = qc_lm)
vals_adj <- 2^vals_adj

##create new assay
assay(res, "norm_bb") <- vals_adj

```


## Evaluate results batches normalization

### PCA after norm batches

```{r, fig.path = IMAGE_PATH}
#' impute assay (cannot take log because introduce negative value and breaks function)
tmp <- assay(res, "norm_bb")
tmp <- apply(tmp, MARGIN = 1, na.unidis)
assays(res)$norm_bb_imputed <- t(tmp)

```

```{r pca-after-bb, fig.path = IMAGE_PATH, fig.height=7, fig.width=18}
# With imputation
vals <- assay(res, "norm_bb_imputed") |>
    log2() |>
    t() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

#save(pca_res, file = file.path(RDATA_PATH, "pca_after-bb.RData"))  #FINDME

#' sample type
p <- plot_pca(as.data.frame(pca_res$x), res$sample_type, col_phenotype)
plot(p)

#' batches
p <- plot_pca(as.data.frame(pca_res$x), res$batch_id, col_batch_id)
plot(p)

#' injection index
p <- plot_pca(as.data.frame(pca_res$x), as.factor(res$injection_index), col_injection_index)
plot(p)

```



```{r eval = !file.exists(paste0(RDATA_PATH, "SumExp_chris_after_bb.RData"))}
save(res, file = file.path(RDATA_PATH, "SumExp_chris_after_bb.RData"))

```


# Evaluate using CV of QC pool values

## CVs overall per normalization method

To estimate performance of normalization, we calculate the CV of CHRIS pool
samples for each normalization strategy:

- raw_filled_imputed
- norm_imputed                   #after median scaling
- norm_wb_imputed                #after withing batches scaling (using inj index lm)
- norm_bb_imputed                #after between batches scaling (using batch id lm)
- norm_lm2_imputed               #after lm with both injection_order and batch_id


```{r calculate CV QCs, message = FALSE, warning = FALSE}
#' transpose data, matrix metabolomics as cols
met_data <- t(assays(res)$norm_bb_imputed)                #FIND_ME!!!
rownames(met_data) <- res$sample_id
#met_data[1:10,1:10]
#dim(met_data)

#' keep only pool samples
qc_data <- met_data[grep("POOL_", rownames(met_data)), ]
#dim(qc_data)
#rownames(qc_data)
#qc_data[1:10,1:10]

#' calculate the CVs for QCs in NAFLD dataset
#x <- qc_data[,1]  #test, OK!
cv_values <- apply(qc_data, 2, function(x) sd(x)/mean(x)) #iter col=feats
df_with_CV_values <- data.frame(x=colnames(qc_data), y=cv_values)
names(df_with_CV_values) <- c("Metabolite", "CV_values")

#' median and mean CV of all the metabolites
median(df_with_CV_values$CV_values)
mean(df_with_CV_values$CV_values)
summary(df_with_CV_values$CV_values)

```

normalization strategy  |  mean
__________________________________
raw_filled_imputed      |  1.1476
norm_imputed            |  1.1738
norm_wb_imputed         |  1.1660
norm_bb_imputed         |  0.9058
norm_lm2_imputed        |  NA


## CVs per batch

Calculate CV per metabolite of the pooled QC samples per batch, plot that
distribution using boxplots for each normalization strategy.

```{r cv per batch, fig.path = IMAGE_PATH, fig.height = 5, fig.width = 7}
#' calculate CV of QC2 per batch
batch_id <- unique(res$batch_id)
#i <- "BATCH0001" #test

#' loop over batches
for (i in batch_id) {
    #' extract QCs of 1 batch
    tmp <- res[,res$batch_id == i & res$sample_type == 'Pool']
    met_data <- t(assays(tmp)$norm_bb_imputed)             #FIND_ME!!!
    rownames(met_data) <- tmp$sample_id

    #' calc CVs
    cv_values <- apply(met_data, 2, function(x) sd(x)/mean(x)) #iter col=feats

    #' append to df containing the overall CVs from previous block
    df_with_CV_values <- cbind(df_with_CV_values, cv_values)
    colnames(df_with_CV_values)[ncol(df_with_CV_values)] <- i
}

#' rm the overal CV values
df_with_CV_values <- subset(df_with_CV_values, select = -CV_values)

#' prep format df for boxplot
df <- melt(df_with_CV_values)
#head(df)

#' boxplot
col <- 'gray65'
p <- plot_multiboxplot(df)
plot(p)

#' summary
summary(df_with_CV_values)

```


# Save Summarized experiment

```{r SummarizedExperiment}
#' Extract results as a SummarizedExperiment
head(res)
save(res, file = paste0(RDATA_PATH, "SumExp_chris_norm.RData")) #save under results

#tmp <- assay(res, 'raw_filled')
#head(tmp)

#' FYI: 11 elem in assays:
#' raw                    #output after PP, see workflow
#' raw_filled
#' raw_filled_imputed
#' norm                   #after median scaling
#' norm_imputed
#' norm_wb                #after withing batches scaling (using inj index lm)
#' norm_wb_imputed
#' norm_bb                #after between batches scaling (using batch id lm)
#' norm_bb_imputed
#' res_qc
#' norm_lm2               #after lm with both injection_order and batch_id
#' norm_lm2_imputed


#' for testing
#' write feature matrix for manual inspection
tmp <- assays(res)$raw_filled_imputed                #FIND_ME!!!
colnames(tmp) <- res$file_name
#tmp[1:10,1:10]
tmp2 <- rowData(res)
tmp2 <- as.data.frame(tmp2)
tmp2 <- cbind(tmp2, tmp)
#tmp2[1:10,1:20]
handle <- file.path(DATA_PATH, 'vm_chris_pos_raw_filled_imputed.txt')
write.table(tmp2, file=handle, sep ="\t", row.names = TRUE, col.names = TRUE)

tmp2 <- colData(res)
tmp2 <- as.data.frame(tmp2)
#tmp2[1:10,1:13]
handle <- file.path(DATA_PATH, 'sm_chris_pos_raw_filled_imputed.txt')
write.table(tmp2, file=handle, sep ="\t", row.names = TRUE, col.names = TRUE)

```

# Acknowledgments

Consulted sources used as basis for code:

- NAFLD_Norm_pos.Rmd

# Session information

R packages used for the analysis:

```{r}
sessionInfo()

```

# References

---
title: "Evaluation data quality of QC samples from 2020-09"
author: "Johannes Rainer, Vinicius Veri"
output:
  BiocStyle::html_document:
    toc: true
    number_sections: false
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
---

```{r biocstyle, echo = FALSE, results = "asis" }
library(BiocStyle)
BiocStyle::markdown()
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

**Modified**: `r file.info("random_QC_samples.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = TRUE, results = "hide", message = FALSE}
## Set general options
options(useFancyQuotes = FALSE)
set.seed(123)

## Define paths:
filename <- "random_QC_samples"
## Path to save the images; remove all old images.
IMAGE_PATH <- paste0("images/", filename, "/")
dir.create(IMAGE_PATH, recursive = TRUE, showWarnings = FALSE)
## Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
dir.create(RDATA_PATH, recursive = TRUE, showWarnings = FALSE)

## Get the number of cpus allocated or fall back to 6
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 6))

rt_cut <- 340

MZML_PATH <- "/data/massspec/mzML/"
if (!dir.exists(MZML_PATH))
    stop("Can not find the directory with the mzML files: ", MZML_PATH)

```

# Introduction

After the Covid-19 caused lockdown the LC-MS system seemed to no longer generate
reproducible data. In this document we evaluate the signal measured for QC
samples in September 2020 (after thorough revision and cleaning but prior
maintenance of the LC-MS system) and compare that signal to the data of random
QC samples measured in the year 2017. In particular, we aim at comparing the TIC
and BPC of all samples and evaluate the retention time and integrated peak
signal for selected ions.


```{r libraries, message = FALSE}
library(readxl)
library(RColorBrewer)
library(xcms)
library(CompMetaboTools)
library(Spectra)

injections <- as.data.frame(read_xlsx("data/random-QC-2017-2020_09.xlsx"))
injections$id <- gsub(".mzML", "", injections$mzML_file)
injections <- injections[order(injections$timestamp), ]
injections$batch <- injections$run_id
injections <- injections[!injections$type %in% c("ACN_IS", "EQ_MIX"), ]

## split by polarity
pd_pos <- injections[injections$polarity == "POS", ]
```

Below we load the positive polarity data, subset to the defined retention time
range and remove unnecessary spectrum metadata.

```{r pos-load, eval = !file.exists(paste0(RDATA_PATH, "data_pos.RData"))}
data_pos <- readMSData(files = paste0(MZML_PATH, pd_pos$mzML_file),
                       pdata = as(AnnotatedDataFrame(pd_pos),
                                  "NAnnotatedDataFrame"),
                       mode = "onDisk")

data_pos <- filterRt(data_pos, c(0, rt_cut))
data_pos <- selectFeatureData(
    data_pos, fcol = c("fileIdx", "spIdx", "acquisitionNum", "retentionTime",
                       "msLevel", "precursorScanNum", "polarity", "centroided",
                       "seqNum")
)
```

# Peak detection and refinement

We perform a centWave-based peak detection followed by a *peak refinement* step
that aims at reducing the peak detection artifacts, such as split peaks or
overlapping peaks. Below we define the parameters for the peak detection and
subsequently perform the analysis.

```{r pos-peak-detection, warning = FALSE, message = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_pos.RData"))}
cwp <- CentWaveParam(
    peakwidth = c(2, 20),
    ppm = 50,
    snthresh = 5,
    mzdiff = 0.001,
    prefilter = c(3, 500),
    noise = 100,
    integrate = 2)

register(MulticoreParam(ncores))
tm <- system.time(
    data_pos <- findChromPeaks(data_pos, param = cwp)
)
save(data_pos, file = paste0(RDATA_PATH, "data_pos.RData"))
```

```{r pos-peak-detection-load, echo = FALSE, warning = FALSE, message = FALSE}
load(paste0(RDATA_PATH, "data_pos.RData"))
if (!any(ls() == "tm"))
    tm <- c(elapsed = 1)
```

Next we refine the identified chromatographic peaks. Processing took
`r tm["elapsed"] / 60` minutes.

```{r pos-peak-refinement, warning = FALSE, message = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_pos_ref.RData"))}
mnp <- MergeNeighboringPeaksParam(
    expandRt = 2,
    expandMz = 0.001,
    ppm = 10,
    minProp = 0.66)

## register(MulticoreParam(workers = ceiling(ncores * 2/3),
##                         timeout = 86400L))
tm <- system.time(
    data_pos <- refineChromPeaks(data_pos, param = mnp, BPPARAM = bpparam())
)
save(data_pos, file = paste0(RDATA_PATH, "data_pos_ref.RData"))
```

```{r pos-peak-refinement-load, echo = FALSE, warning = FALSE, message = FALSE}
load(paste0(RDATA_PATH, "data_pos_ref.RData"))
if (!any(ls() == "tm"))
    tm <- c(elapsed = 1)
```

```{r echo = FALSE, eval = FALSE}
## Just testing the joyPlot...
plotChromPeaks(data_pos, file = 12)
abline(v = c(150, 174))

a <- filterFile(data_pos, file = 12)
b <- filterFile(data_pos, file = 2)
plot(chromatogram(a, include = "none"))
abline(v = c(150, 174))
par(mfrow = c(1, 2))
## Focusing on large-mass peaks
joyPlot(b, rt = c(150, 174), mz = c(400, 1000), yoffset = 0.7)
joyPlot(a, rt = c(150, 174), mz = c(400, 1000), yoffset = 0.7)

plotChromPeaks(data_pos, file = 12)
abline(v = c(40, 60))
joyPlot(a, rt = c(40, 60), yoffset = 0.7, mz = c(200, 1000), spacing = "equal", legend = TRUE)
grid()
## Why the hell is this signal shifted in RT?
## "Cluster" compound already in solution -> different rt.

## Phosoholipid peak
plot(chromatogram(a, include = "none"))
abline(v = c(125, 143))
par(mfrow = c(1, 2))
joyPlot(b, rt = c(125, 143), yoffset = 0.7)
joyPlot(a, rt = c(125, 143), yoffset = 0.7)

## The *real* version...
par(bg = "#000000")
joyPlot(a, col = "#ffffff", peakBg = "#000000aa", mz = c(400, 1000),
        yoffset = 0.8, rt = c(150, 174))

```

Processing took `r tm["elapsed"] / 60` minutes.

# Signal evaluation

## Base peak and total ion chromatograms

Next we extract the base peak and total ion chromatogram.

```{r chrs}
data_pos$year_month <- paste0(data_pos$year, "-", data_pos$month)
bpchr <- chromatogram(as(data_pos, "OnDiskMSnExp"), aggregationFun = "max")
tichr <- chromatogram(as(data_pos, "OnDiskMSnExp"), aggregationFun = "sum")
```

Below we plot the BPC and the TIC for the data set.

```{r chr-plots, fig.path = IMAGE_PATH, caption = "BPC and TIC of the data set", fig.width = 12, fig.height = 10, echo = FALSE}
col_year_month <- brewer.pal(8, "Set1")[-6]
names(col_year_month) <- unique(data_pos$year_month)
par(mfrow = c(2, 1), mar = c(2, 4.5, 2, 1))
plot(bpchr, col = paste0(col_year_month[bpchr$year_month], 80), main = "BPC",
     xlim = c(0, 220))
grid()
legend("topright", legend = names(col_year_month), lty = 1, col = col_year_month)
plot(tichr, col = paste0(col_year_month[tichr$year_month], 80), main = "TIC",
     xlim = c(0, 220))
grid()
```

The signal in September 2020 seems to start and stop earlier than in previous
years or also in February 2020. The bimodal *phospholipid* peak present in most
samples seems to be replaced by a single peak in some of the September samples,
with the exception of the last 5 samples which again show a large phospholipid
peak and a less noisy baseline.

Next we plot the distribution of the base peak and total ion signal per sample
to evaluate potential differences in average intensities.

```{r chr-boxplot, fig.path = IMAGE_PATH, caption = "Distribution of base peak and total ion chromatograms.", fig.width = 8, fig.height = 8, echo = FALSE}
par(mfrow = c(2, 1), mar = c(1, 4.5, 1, 1))
boxplot(lapply(bpchr, function(z) log2(intensity(z))), outline = FALSE,
        ylab = expression(log[2]~base~peak~intensity), xaxt = "n",
        main = "QC samples, positive polarity",
        col = paste0(col_year_month[bpchr$year_month], 40))
grid(nx = NA, ny = NULL)
boxplot(lapply(tichr, function(z) log2(intensity(z))), outline = FALSE,
        ylab = expression(log[2]~total~ion~intensity), xaxt = "n",
        main = "QC samples, positive polarity",
        col = paste0(col_year_month[tichr$year_month], 40))
grid(nx = NA, ny = NULL)
```

The distribution of base peak and total ion signal clearly shows batch
differences over the years, with the QC samples from the same batch yielding,
with the exception of the first 2 from the September 2020 (pink samples), about
the same signal. Also, the signal for the following 4 samples seems to
continuously decrease. This change is however comparably small and even in
previous batches such a difference was observed. The last 5 samples show almost
no such drift.


## Peak detection results

Next we evaluate the number of identified peaks per sample.

```{r peak-count-table, results = "asis", echo = FALSE}
library(pander)
T <- matrix(as.integer(table(chromPeaks(data_pos)[, "sample"])), ncol = 1)
colnames(T) <- "peak count"
rownames(T) <- data_pos$name
T <- data.frame(T, year = data_pos$year, month = data_pos$month,
                day = data_pos$day, check.names = FALSE)
pandoc.table(T, style = "rmarkdown",
             caption = "Number of peaks identified in each sample")
```

There are considerable differences in the number of detected peaks across the
batches.

At last we evaluate the signal for selected compounds (from the set of
standards) and compare their retention time across the batches as well as their
quantified signal. To this end we load first the data with the expected
retention time and ion for the set of standards.

```{r standards}
library(CompoundDb)
library(Rdisop)
std_info <- read.table(
    "https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/standards_dilution.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
std_info <- std_info[!is.na(std_info[, "POS"]), ]
rownames(std_info) <- 1:nrow(std_info)
std_info$mzneut = NA
std_info$mz_ion = NA
for (i in seq(nrow(std_info))) {
    if (grepl("C", std_info$formula[i])){
        std_info$mzneut[i] <- getMolecule(
            as.character(std_info$formula[i]))$exactmass
    } else {
        std_info$mzneut[i] = as.numeric(std_info$formula[i])
    }
    ## Calculate also the m/z
    std_info$mz_ion[i] <- unlist(
        mass2mz(std_info$mzneut[i],
                adduct = as.character(
                    std_info[i, "POS"])))
}
```

We then extract the EIC for each standard, visually inspect all of the plots and
determine for which standards we have an unambiguous mapping to a single peak.

```{r pos-eic-plots, echo = TRUE}
## Two-step approach: define first the rt/mz region for each standard and
## Extract the chromatogram afterwards.
std_info_mz_rt <- matrix(
    ncol = 4, nrow = nrow(std_info),
    dimnames = list(std_info$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(std_info)) {
    pks <- chromPeaks(data_pos, mz = std_info$mz_ion[i], ppm = 50)
    if (nrow(pks)) {
        rtdiff <- abs(pks[, "rt"] - std_info$RT[i])
        keep <- which(rtdiff < 40)
        if (length(keep)) {
            pks <- pks[keep, , drop = FALSE]
            mzr <- range(pks[, c("mzmin", "mzmax")])
            rtr <- range(pks[, c("rtmin", "rtmax")], std_info$RT[i])
            std_info_mz_rt[i, ] <- c(mzr, rtr)
        }
    }
}
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]
## Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr <- chromatogram(
    data_pos, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
## Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_year_month[as.character(data_pos$year_month)]
for (i in 1:nrow(std_info)) {
    cmpname <- std_info$name[i]
    filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
                       "_POS", ".png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    ## This is just to indicate identified peaks with a rectangle.
    xcms:::.add_chromatogram_peaks(
               chr, pks,
               col = paste0(sample_colors[pks[, "column"]], 40),
               bg = NA,
               type = "rectangle")
    abline(v = std_info$RT[i])
    dev.off()
}
```

```{r standards-manual-selection, echo = FALSE}
std_info$rtmin <- NA_real_
std_info$rtmax <- NA_real_
## Add the min and max retention time for compounds we select for further
## analysis
std_info$rtmin[std_info$name == "3-Nitrotyrosine"] <- 143
std_info$rtmax[std_info$name == "3-Nitrotyrosine"] <- 170
std_info$rtmin[std_info$name == "ADMA"] <- 163
std_info$rtmax[std_info$name == "ADMA"] <- 190
std_info$rtmin[std_info$name == "Alanine"] <- 165
std_info$rtmax[std_info$name == "Alanine"] <- 180
std_info$rtmin[std_info$name == "Arginine"] <- 170
std_info$rtmax[std_info$name == "Arginine"] <- 208
std_info$rtmin[std_info$name == "Asparagine"] <- 177
std_info$rtmax[std_info$name == "Asparagine"] <- 200
std_info$rtmin[std_info$name == "Caffeine"] <- 32
std_info$rtmax[std_info$name == "Caffeine"] <- 40
std_info$rtmin[std_info$name == "Citrulline"] <- 170
std_info$rtmax[std_info$name == "Citrulline"] <- 200
std_info$rtmin[std_info$name == "Creatine"] <- 160
std_info$rtmax[std_info$name == "Creatine"] <- 190
std_info$rtmin[std_info$name == "Cystine"] <- 205
std_info$rtmax[std_info$name == "Cystine"] <- 225
std_info$rtmin[std_info$name == "Diethyl malonate"] <- 25
std_info$rtmax[std_info$name == "Diethyl malonate"] <- 35
std_info$rtmin[std_info$name == "Glutamine"] <- 170
std_info$rtmax[std_info$name == "Glutamine"] <- 200
std_info$rtmin[std_info$name == "Glyceraldehyde 2-phosphate"] <- 180
std_info$rtmax[std_info$name == "Glyceraldehyde 2-phosphate"] <- 225
std_info$rtmin[std_info$name == "Glycero-phosphocholine"] <- 185
std_info$rtmax[std_info$name == "Glycero-phosphocholine"] <- 200
std_info$rtmin[std_info$name == "Glycine"] <- 165
std_info$rtmax[std_info$name == "Glycine"] <- 180
std_info$rtmin[std_info$name == "Histidine"] <- 170
std_info$rtmax[std_info$name == "Histidine"] <- 205
std_info$rtmin[std_info$name == "Homocysteine"] <- 165
std_info$rtmax[std_info$name == "Homocysteine"] <- 180
std_info$rtmin[std_info$name == "Indoleacetic acid"] <- 32
std_info$rtmax[std_info$name == "Indoleacetic acid"] <- 40
std_info$rtmin[std_info$name == "Inosine"] <- 135
std_info$rtmax[std_info$name == "Inosine"] <- 155
std_info$rtmin[std_info$name == "L-Aspartic Acid"] <- 175
std_info$rtmax[std_info$name == "L-Aspartic Acid"] <- 195
std_info$rtmin[std_info$name == "L-Glutamic Acid"] <- 165
std_info$rtmax[std_info$name == "L-Glutamic Acid"] <- 190
std_info$rtmin[std_info$name == "Lysine"] <- 170
std_info$rtmax[std_info$name == "Lysine"] <- 205
std_info$rtmin[std_info$name == "Methioninesulfoxide"] <- 178
std_info$rtmax[std_info$name == "Methioninesulfoxide"] <- 193
std_info$rtmin[std_info$name == "N-Acetylornithine"] <- 170
std_info$rtmax[std_info$name == "N-Acetylornithine"] <- 210
std_info$rtmin[std_info$name == "Ornithine"] <- 175
std_info$rtmax[std_info$name == "Ornithine"] <- 205
std_info$rtmin[std_info$name == "Putrescine"] <- 155
std_info$rtmax[std_info$name == "Putrescine"] <- 170
std_info$rtmin[std_info$name == "Serine"] <- 175
std_info$rtmax[std_info$name == "Serine"] <- 190
std_info$rtmin[std_info$name == "Sphingosine"] <- 25
std_info$rtmax[std_info$name == "Sphingosine"] <- 40
std_info$rtmin[std_info$name == "Suberic Acid"] <- 30
std_info$rtmax[std_info$name == "Suberic Acid"] <- 40
std_info$rtmin[std_info$name == "Taurine"] <- 165
std_info$rtmax[std_info$name == "Taurine"] <- 180
std_info$rtmin[std_info$name == "Threonine"] <- 165
std_info$rtmax[std_info$name == "Threonine"] <- 190
std_info$rtmin[std_info$name == "Tyrosine"] <- 160
std_info$rtmax[std_info$name == "Tyrosine"] <- 180
std_info <- std_info[!is.na(std_info$rtmin), ]

## Re-create the m/z and rt range matrix
std_info_mz_rt <- matrix(
    ncol = 4, nrow = nrow(std_info),
    dimnames = list(std_info$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(std_info)) {
    pks <- chromPeaks(data_pos, mz = std_info$mz_ion[i], ppm = 50,
                      rt = c(std_info$rtmin[i], std_info$rtmax[i]))
    if (nrow(pks)) {
        mzr <- range(pks[, c("mzmin", "mzmax")])
        rtr <- range(pks[, c("rtmin", "rtmax")], std_info$RT[i])
        rtr[1] <- rtr[1] - 1
        rtr[2] <- rtr[2] + 1
        std_info_mz_rt[i, ] <- c(mzr, rtr)
    }
}

std_chr <- chromatogram(
    data_pos, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = std_info_mz_rt[, c("rtmin", "rtmax")],
    aggregationFun = "max")
fData(std_chr) <- cbind(fData(std_chr),
                        std_info[, c("name", "HMDB.code", "formula",
                                     "POS", "RT")])
```

Next we select for each of the selected standards the largest peak signal in
each sample (and also the retention time for that peak).

```{r select-peak-signal}
std_rt <- matrix(ncol = ncol(std_chr), nrow = nrow(std_chr),
                 dimnames = dimnames(std_chr))
rownames(std_info) <- std_info$name
rownames(std_rt) <- rownames(std_info)
std_int <- std_rt
std_max <- std_int
for (i in 1:nrow(std_rt)) {
    tmp <- std_chr[i, ]
    tmp <- split.data.frame(chromPeaks(tmp), chromPeaks(tmp)[, "column"])
    tmp <- lapply(tmp, function(z) z[which.max(z[, "maxo"]), ])
    rts <- vapply(tmp, function(z) z["rt"], numeric(1))
    ints <- vapply(tmp, function(z) z["into"], numeric(1))
    maxs <- vapply(tmp, function(z) z["maxo"], numeric(1))
    std_rt[i, names(rts)] <- rts
    std_int[i, names(ints)] <- ints
    std_max[i, names(maxs)] <- maxs
}
idx <- order(std_info$RT)
std_info <- std_info[idx, ]
std_chr <- std_chr[idx, ]
std_rt <- std_rt[idx, ]
std_int <- std_int[idx, ]
std_max <- std_max[idx, ]
```

The table below lists the manually selected standards which will be used for the
subsequent analysis.

```{r select-standards-table, echo = FALSE, results = "asis"}
T <- data.frame(std_info[, c("name", "mz_ion")],
                rt_mean = apply(std_rt, 1, mean, na.rm = TRUE),
                rt_sd = apply(std_rt, 1, sd, na.rm = TRUE),
                into_mean = apply(std_int, 1, mean, na.rm = TRUE),
                into_cv = rowRsd(std_int, na.rm = TRUE))
pandoc.table(T, style = "rmarkdown",
             caption = "Selected standards.")
```

Retention time shifts for about half of the standards is relatively large (over
6 seconds). Coefficient of variation are large for all standards.

```{r export-eic-selected-standards, echo = FALSE, message = FALSE}
dr <- paste0(IMAGE_PATH, "selected-standards/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_year_month[as.character(data_pos$year_month)]
for (i in seq_len(nrow(std_chr))) {
    fn <- paste0(dr, std_info$name[i], ".png")
    png(file = fn, width = 16, height = 10, units = "cm",
        res = 300, pointsize = 4)
    par(mfrow = c(1, 2), mar = c(5, 4.2, 2, 0.5))
    chr <- std_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    ## Indicate the selected peak position.
    points(std_rt[i, ], std_max[i, ], col = sample_colors)
    grid()
    boxplot(log2(std_int), col = paste0(sample_colors, 80), las = 2,
            names = chr$year_month, ylab = expression(log[2]~intensity))
    points(x = seq_len(ncol(std_int)), log2(std_int[i, ]), pch = 16,
           type = "o", cex = 1.5)
    grid()
    dev.off()
}
```

In addition to the standards we are also identifying chromatographic peaks for
the internal standards (code not shown).

```{r is-define, echo = FALSE}
is_info <- read.table(
    "https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/internal_standards.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
is_info <- is_info[!is.na(is_info[, "POS"]), ]
rownames(is_info) <- 1:nrow(is_info)
is_info$mzneut = NA
is_info$mz_ion = NA
for (i in seq(nrow(is_info))) {
    if (grepl("C", is_info$formula[i])){
        is_info$mzneut[i] <- getMolecule(
            as.character(is_info$formula[i]))$exactmass
    } else {
        is_info$mzneut[i] = as.numeric(is_info$formula[i])
    }
    ## Calculate also the m/z
    is_info$mz_ion[i] <- unlist(
        mass2mz(is_info$mzneut[i],
                adduct = as.character(
                    is_info[i, "POS"])))
}

## Two-step approach: define first the rt/mz region for each standard and
## Extract the chromatogram afterwards.
is_info_mz_rt <- matrix(
    ncol = 4, nrow = nrow(is_info),
    dimnames = list(is_info$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(is_info)) {
    pks <- chromPeaks(data_pos, mz = is_info$mz_ion[i], ppm = 50)
    if (nrow(pks)) {
        rtdiff <- abs(pks[, "rt"] - is_info$RT[i])
        keep <- which(rtdiff < 40)
        if (length(keep)) {
            pks <- pks[keep, , drop = FALSE]
            mzr <- range(pks[, c("mzmin", "mzmax")])
            rtr <- range(pks[, c("rtmin", "rtmax")], is_info$RT[i])
            is_info_mz_rt[i, ] <- c(mzr, rtr)
        }
    }
}
is_info <- is_info[!is.na(is_info_mz_rt[, "mzmin"]), ]
is_info_mz_rt <- is_info_mz_rt[!is.na(is_info_mz_rt[, "mzmin"]), ]
## Extract the ion chromatogram for each standard
rtr <- is_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
is_info_chr <- chromatogram(
    data_pos, mz = is_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
## Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_year_month[as.character(data_pos$year_month)]
for (i in 1:nrow(is_info)) {
    cmpname <- is_info$name[i]
    filename <- paste0(dr, "IS-", gsub("%", "p", cmpname, fixed = TRUE),
                       "_", "POS", ".png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- is_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(cmpname, ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    ## This is just to indicate identified peaks with a rectangle.
    xcms:::.add_chromatogram_peaks(
               chr, pks,
               col = paste0(sample_colors[pks[, "column"]], 40),
               bg = NA,
               type = "rectangle")
    abline(v = is_info$RT[i])
    dev.off()
}

is_info$rtmin <- NA_real_
is_info$rtmax <- NA_real_
## Add the min and max retention time for compounds we select for further
## analysis
is_info$rtmin[is_info$name == "Glycine (13C2, 99%; 15N, 99%)"] <- 165
is_info$rtmax[is_info$name == "Glycine (13C2, 99%; 15N, 99%)"] <- 175
is_info$rtmin[is_info$name == "L-Alanine (13C3, 99%; 15N, 99%)"] <- 165
is_info$rtmax[is_info$name == "L-Alanine (13C3, 99%; 15N, 99%)"] <- 175
is_info$rtmin[is_info$name == "L-Arginine HCl (13C6, 99%; 15N4, 99%)"] <- 170
is_info$rtmax[is_info$name == "L-Arginine HCl (13C6, 99%; 15N4, 99%)"] <- 200
is_info$rtmin[is_info$name == "L-Aspartic acid (13C4, 99%; 15N, 99%)"] <- 170
is_info$rtmax[is_info$name == "L-Aspartic acid (13C4, 99%; 15N, 99%)"] <- 195
is_info$rtmin[is_info$name == "L-Cystine (13C6, 99%; 15N2, 99%)"] <- 205
is_info$rtmax[is_info$name == "L-Cystine (13C6, 99%; 15N2, 99%)"] <- 230
is_info$rtmin[is_info$name == "L-Glutamic acid (13C5, 99%; 15N, 99%)"] <- 165
is_info$rtmax[is_info$name == "L-Glutamic acid (13C5, 99%; 15N, 99%)"] <- 190
is_info$rtmin[is_info$name == "L-Histidine HCl H2O (13C6; 15N3, 99%)"] <- 170
is_info$rtmax[is_info$name == "L-Histidine HCl H2O (13C6; 15N3, 99%)"] <- 210
is_info$rtmin[is_info$name == "L-Lysine 2HCl (13C6, 99%; 15N2, 99%)"] <- 170
is_info$rtmax[is_info$name == "L-Lysine 2HCl (13C6, 99%; 15N2, 99%)"] <- 210
is_info$rtmin[is_info$name == "L-Methionine (13C5, 99%; 15N, 99%)"] <- 155
is_info$rtmax[is_info$name == "L-Methionine (13C5, 99%; 15N, 99%)"] <- 167
is_info$rtmin[is_info$name == "L-Phenylalanine (13C9, 99%; 15N, 99%)"] <- 140
is_info$rtmax[is_info$name == "L-Phenylalanine (13C9, 99%; 15N, 99%)"] <- 163
is_info$rtmin[is_info$name == "L-Proline (13C5, 99%; 15N, 99%)"] <- 163
is_info$rtmax[is_info$name == "L-Proline (13C5, 99%; 15N, 99%)"] <- 177
is_info$rtmin[is_info$name == "L-Serine (13C3, 99%; 15N, 99%)"] <- 175
is_info$rtmax[is_info$name == "L-Serine (13C3, 99%; 15N, 99%)"] <- 190
is_info$rtmin[is_info$name == "L-Threonine (13C4, 99%; 15N, 99%)"] <- 165
is_info$rtmax[is_info$name == "L-Threonine (13C4, 99%; 15N, 99%)"] <- 185
is_info$rtmin[is_info$name == "L-Tyrosine (13C9, 99%; 15N, 99%)"] <- 165
is_info$rtmax[is_info$name == "L-Tyrosine (13C9, 99%; 15N, 99%)"] <- 180
is_info$rtmin[is_info$name == "L-Valine (13C5, 99%; 15N, 99%)"] <- 160
is_info$rtmax[is_info$name == "L-Valine (13C5, 99%; 15N, 99%)"] <- 172
is_info <- is_info[!is.na(is_info$rtmin), ]

## Re-create the m/z and rt range matrix
is_info_mz_rt <- matrix(
    ncol = 4, nrow = nrow(is_info),
    dimnames = list(is_info$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(is_info)) {
    pks <- chromPeaks(data_pos, mz = is_info$mz_ion[i], ppm = 50,
                      rt = c(is_info$rtmin[i], is_info$rtmax[i]))
    if (nrow(pks)) {
        mzr <- range(pks[, c("mzmin", "mzmax")])
        rtr <- range(pks[, c("rtmin", "rtmax")], is_info$RT[i])
        rtr[1] <- rtr[1] - 1
        rtr[2] <- rtr[2] + 1
        is_info_mz_rt[i, ] <- c(mzr, rtr)
    }
}

is_chr <- chromatogram(
    data_pos, mz = is_info_mz_rt[, c("mzmin", "mzmax")],
    rt = is_info_mz_rt[, c("rtmin", "rtmax")],
    aggregationFun = "max")
fData(is_chr) <- cbind(fData(is_chr),
                       is_info[, c("name", "abbreviation", "formula",
                                   "POS", "RT")])

## retention time and intensity matrices
is_rt <- matrix(ncol = ncol(is_chr), nrow = nrow(is_chr),
                dimnames = dimnames(is_chr))
rownames(is_info) <- is_info$name
rownames(is_rt) <- rownames(is_info)
is_int <- is_rt
is_max <- is_int
for (i in 1:nrow(is_rt)) {
    tmp <- is_chr[i, ]
    tmp <- split.data.frame(chromPeaks(tmp), chromPeaks(tmp)[, "column"])
    tmp <- lapply(tmp, function(z) z[which.max(z[, "maxo"]), ])
    rts <- vapply(tmp, function(z) z["rt"], numeric(1))
    ints <- vapply(tmp, function(z) z["into"], numeric(1))
    maxs <- vapply(tmp, function(z) z["maxo"], numeric(1))
    is_rt[i, names(rts)] <- rts
    is_int[i, names(ints)] <- ints
    is_max[i, names(maxs)] <- maxs
}
idx <- order(is_info$RT)
is_info <- is_info[idx, ]
is_chr <- is_chr[idx, ]
is_rt <- is_rt[idx, ]
is_int <- is_int[idx, ]
is_max <- is_max[idx, ]
```

The table of the (selected) internal standards is shown below.

```{r is-table, echo = FALSE, results = "asis"}
T <- data.frame(is_info[, c("name", "mz_ion")],
                rt_mean = apply(is_rt, 1, mean, na.rm = TRUE),
                rt_sd = apply(is_rt, 1, sd, na.rm = TRUE),
                into_mean = apply(is_int, 1, mean, na.rm = TRUE),
                into_cv = rowRsd(is_int, na.rm = TRUE))
pandoc.table(T, style = "rmarkdown",
             caption = "Internal standards.")
```

With the exception of 3 standards, retention time shifts of all internal
standards are comparable. Also, the coefficient of variation are for most
between 0.4 and 0.5.

```{r export-eic-is, echo = FALSE, message = FALSE}
dr <- paste0(IMAGE_PATH, "internal-standards/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_year_month[as.character(data_pos$year_month)]
for (i in seq_len(nrow(is_chr))) {
    fn <- paste0(dr, "IS-", gsub("%", "p", is_info$name[i], fixed = TRUE),
                 ".png")
    png(file = fn, width = 16, height = 10, units = "cm",
        res = 300, pointsize = 4)
    par(mfrow = c(1, 2), mar = c(5, 4.2, 2, 0.5))
    chr <- is_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(is_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    ## Indicate the selected peak position.
    points(is_rt[i, ], is_max[i, ], col = sample_colors)
    grid()
    boxplot(log2(is_int), col = paste0(sample_colors, 80), las = 2,
            names = chr$year_month, ylab = expression(log[2]~intensity))
    points(x = seq_len(ncol(is_int)), log2(is_int[i, ]), pch = 16,
           type = "o", cex = 1.5)
    grid()
    dev.off()
}
```



## Comparison of batches

In this section we compare the signal of the selected features across the
batches. This complements the analysis performed on the base peak and total ion
signal performed above and aims at evaluating within and between-batch signals.

```{r batches-signal-boxplot, echo = FALSE, fig.width = 12, fig.height = 8, fig.cap = "Per sample distribution of base peak intensities (top) and signal distribution of selected ions (middle) and internal standards (bottom) across batches.", fig.path = IMAGE_PATH}
par(mfrow = c(3, 1), mar = c(1, 4.5, 1, 1))
boxplot(lapply(bpchr, function(z) log2(intensity(z))), outline = FALSE,
        ylab = expression(log[2]~base~peak~intensity), xaxt = "n",
        main = "QC samples, positive polarity",
        col = paste0(col_year_month[bpchr$year_month], 40))
grid(nx = NA, ny = NULL)
boxplot(log2(std_int), ylab = expression(log[2]~intensity), xaxt = "n",
        main = "Selected ions",
        col = paste0(col_year_month[bpchr$year_month], 40))
grid(nx = NA, ny = NULL)
boxplot(log2(is_int), ylab = expression(log[2]~intensity), xaxt = "n",
        main = "Internal standards",
        col = paste0(col_year_month[bpchr$year_month], 40))
grid(nx = NA, ny = NULL)

```

Considering only the selected ions or the internal satndards, differences within
each batch and also between batches (except from the 2 first samples) are
smaller than for the base peak signal. This suggests the base peak signal to be
eventually more affected by background or non-specific noise. Also, differences
in average signal for the last 5 samples is very small suggesting that the data
within this batch (and the previous one) is (relatively) reproducible.

We next evaluate the signal across samples separately for each feature.

```{r batches-signal-per-feature, echo = FALSE, fig.width = 8, fig.height = 4, fig.cap = "Signal of selected ions across batches/samples.", fig.path = IMAGE_PATH}
par(mfrow = c(1, 1), mar = c(1, 4.5, 1, 1))
plot(xlim = c(1, ncol(std_int)), ylim = range(log2(std_int), na.rm = TRUE),
     3, 3, pch = NA, ylab = expression(log[2]~intensity),
     main = "Selected ions")
grid()
for (i in seq_len(nrow(std_int))) {
    points(x = seq_len(ncol(std_int)), log2(std_int[i, ]), col = "#00000060",
           type = "l")
}

```

Most of the features show the same pattern across samples. This suggests
*global* batch-specific signal shifts which could be adjusted by the
between-batch normalization. There are however some features which have
considerably lower intensities in the last batches from September 2020 (one
example being Glycero-phosphocholine which was not detected in most of these
batches).

To further evaluate whether the differences in feature concentrations are
related to global signal differences we plot the total ion signal of each sample
against the average intensity of the standards in that sample.

```{r batches-ti-vs-avg-int, echo = FALSE, fig.width = 12, fig.height = 6, fig.cap = "Total ion signal (x-axis) against average intensity of selected standards (left) and internal standards (right) per sample.", fig.path = IMAGE_PATH}
ti <- log2(vapply(tichr, function(z) sum(intensity(z), na.rm = TRUE),
                  numeric(1)))
std_median <- apply(log2(std_int), 2, median, na.rm = TRUE)
is_median <- apply(log2(is_int), 2, median, na.rm = TRUE)

par(mfrow = c(1, 2))
plot(ti, std_median,
     xlab = "total ion intensity", ylab = "median intensity of standards",
     main = "Selected ions")
L <- lm(std_median ~ ti)
abline(L)
plot(ti, is_median,
     xlab = "total ion intensity", ylab = "median intensity of standards",
     main = "Internal standards")
L <- lm(is_median ~ ti)
abline(L)
```

Indeed, the average intensity of peaks of the selected standards and for the
internal standards is related to the total signal measured by the MS. Next we
evaluate for each standard its relationship with the total ion signal.

```{r std-int-to-ti-table, echo = FALSE, results = "asis"}
std_lm <- vector("list", nrow(std_int))
for (i in seq_len(nrow(std_int))) {
    y <- log2(std_int[i, ])
    std_lm[[i]] <- lm(y ~ ti)
}

T <- data.frame(name = rownames(std_int),
                slope = vapply(std_lm, function(z) z$coefficients[2],
                               numeric(1)),
                r.squared = vapply(std_lm, function(z) summary(z)$r.squared,
                                   numeric(1)))
pandoc.table(
    T, style = "rmarkdown",
    caption = paste0("Relationship between intensities of standards to the ",
                     "total ion signal of a sample."))
```

For many standards there is a correlation between the intensities and the total
ion signal of the samples. Some however, specifically *Sphingosine*, *Inosine*,
*3-Nitrotyrosine*, *Glycine*, *ADMA*, *Lysine*, *Glycero-phosphocholine* and
*Cystine* this correlation is either absent or poor. We will investigate this in
more detail in the next section.

Next we perform the same analysis for the internal standards.

```{r is-int-to-ti-table, echo = FALSE, results = "asis"}
is_lm <- vector("list", nrow(is_int))
for (i in seq_len(nrow(is_int))) {
    y <- log2(is_int[i, ])
    is_lm[[i]] <- lm(y ~ ti)
}

T <- data.frame(name = rownames(is_int),
                slope = vapply(is_lm, function(z) z$coefficients[2],
                               numeric(1)),
                r.squared = vapply(is_lm, function(z) summary(z)$r.squared,
                                   numeric(1)))
pandoc.table(
    T, style = "rmarkdown",
    caption = paste0("Relationship between intensities of internal standards ",
                     "to the total ion signal of a sample."))
```

For most internal standards their intensity correlates with the total ion signal
per sample. Exceptions are *Glycine* and *L-Cystine*.


## Feature-wise analysis

In this analysis we evaluate whether some features are more affected by
intensity differences or retention time shifts than others and try to find
possible explanations for this. At first we evaluate whether some features are
more affected by retention time shifts (and/or intensity differences) than
others. Thus we evaluate if the retention time shifts are global or
feature-specific (or rt) dependent.

```{r feature-rt-shift-boxplot, fig.path = IMAGE_PATH, fig.width = 7, fig.height = 7, fig.cap = "Per-feature retention time difference across the analyzed batches."}
idx_rt <- order(std_info$rtmin)
par(mar = c(7, 4.2, 1, 1))
boxplot(t(std_rt[idx_rt, ]), las = 2, ylab = "retention time")
grid()
```

Some standards show only very small variations in retention time while others
have large retention time shifts between batches. It seems that compounds
eluting very early are less affected by retention time shifts (because they in
fact are not retained in the column). Interestingly, most standards with large
retention time shifts elute at around 180 seconds. However, at that time there
are also standards that are not or much less affected by retention time shifts.

Next we ask the question:
- is the retention time shift dependent on the feature's m/z or intensity?

To evaluate this potential dependency we plot the standard deviation of the
feature's retention time against its m/z or average intensity (across all
samples).

```{r feature-rt-shift-dependency, fig.path = IMAGE_PATH, fig.width = 15, fig.height = 5, fig.cap = "Per-feature retention time difference across the analyzed batches."}
par(mfrow = c(1, 3))
plot(std_info$mz_ion, apply(std_rt, 1, sd, na.rm = TRUE),
     xlab = "m/z", ylab = "sd retention time")
grid()
plot(apply(log2(std_int), 1, mean, na.rm = TRUE),
     apply(std_rt, 1, sd, na.rm = TRUE),
     xlab = "mean log2 intensity", ylab = "sd retention time")
grid()
plot(apply(log2(std_int), 1, sd, na.rm = TRUE),
     apply(std_rt, 1, sd, na.rm = TRUE),
     xlab = "sd log2 intensity", ylab = "sd retention time")
grid()

```

There seems to be no dependency between m/z or intensity values and retention
time shifts and also no relationship between variation in retention time and
variation in intensity.

Next evaluate the per-feature variance in intensities (across samples).

```{r feature-int-boxplot, fig.path = IMAGE_PATH, fig.width = 9, fig.height = 7, fig.cap = "Per-feature intensity difference across the analyzed batches."}
par(mar = c(9, 4.2, 1, 1))
boxplot(log2(t(std_int[idx_rt, ])), las = 2, ylab = "log2 intensity")
grid(ny = NULL, nx = NA)
```

Intensity differences seem to be feature-specific, with high abundance features
seeming to have lower variance. To evaluate a potential relationship between
intensity and variance we plot below the average intensity against its standard
deviation for each feature.

```{r feature-int-mean-vs-sd, fig.path = IMAGE_PATH, fig.width = 7, fig.height = 7, fig.cap = "Average intensity for each feature against its standard deviation."}
plot(apply(log2(std_int), 1, sd, na.rm = TRUE),
     apply(log2(std_int), 1, mean, na.rm = TRUE),
     xlab = "sd log2 intensity", ylab = "mean log2 intensity")
grid(ny = NULL, nx = NA)
```

Again, no clear dependency is detectable. Thus, the variance in intensity seems
to be feature specific, but not dependent on the total signal of the standard.

As we have already seen in the previous section, for most standards the
intensity follows the total ion signal of the sample (and hence batch). Only for
a handful of features there was no such relationship. We are next trying to
understand why these standards yield different intensities between batches. At
first we evaluate the full scan at peak position for these standards in each
sample. We thus extract next the full scan for each standard.

```{r extract-full-scan}
## Replace NAs with median of row.
std_rt_nona <- std_rt
for (i in seq_len(nrow(std_rt))) {
    nas <- is.na(std_rt[i, ])
    if (any(nas))
        std_rt_nona[i, nas] <- median(std_rt[i, !nas])
}

## We want to get for each sample the spectrum at the peak position, or if no
## peak was identified on the median rt in all other samples.
## As a result we want to get a list (each element being for one standard) of
## Spectra objects (one spectrum per sample/file).
which_rt_file <- function(rt, file, x) {
    sel <- fromFile(x) == file
    idx <- which.min(abs(rtime(x)[sel] - rt))
    which.max(sel) + idx - 1
}
std_sp <- vector("list", nrow(std_info))
names(std_sp) <- rownames(std_info)
for (i in seq_along(std_sp)) {
    idx <- mapply(which_rt_file, std_rt_nona[i, ],
                  seq_len(ncol(std_rt_nona)), MoreArgs = list(x = data_pos))
    std_sp[[i]] <- Spectra(extractSpectraData(data_pos[idx]))
}

```

The first standard is *Sphingosine*. As we can see in the plot below, the
intensities measured in September 2020 are much lower (compared to the median
intensity of all standards) than in all other batches.

![](images/random_QC_samples/selected-standards/Sphingosine.png)

We next calculate m/z values for all potential adducts of the compound and
filter the full scan to only contain these.

```{r}
i <- which(std_info$name == "Sphingosine")
sps <- std_sp[[i]]

adds <- mass2mz(std_info$mzneut[i],
                adduct = adducts(polarity = "positive"))[[1]]
adds <- sort(adds[adds > 0 & adds < 1000])

sps_adds <- filterMzValues(sps, mz = adds, ppm = 20)
```

Next we compare the MS1 spectrum containing only peaks representing potential
adducts of the compound (*ion spectrum*) for Sphingosine in a sample from
February 2020 to one from September 2020.

```{r sphingosine-ion-spectrum-mirror-14-15, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 8, fig.height = 8}
label_function <- function(x) {
    names(adds)[MsCoreUtils::closest(mz(x)[[1L]], adds,
                                     tolerance = 0, ppm = 40,
                                     duplicates = "closest")]
}
plotSpectraMirror(sps_adds[14], sps_adds[15], ppm = 40,
                  main = paste0(std_info$name[i], "; sample 14/15"),
                  labels = label_function, labelPos = 4, labelSrt = 45)
abline(v = std_info$mz_ion[i], lty = 3, col = "#ff000080")

## Which spectra have the [M+H]+ ion?
containsMz(sps_adds, mz = std_info$mz_ion[i], ppm = 40, tolerance = 0)
```

In sample 14 the [M+H]+ ion of Sphingosine yields the largest signal while this
is not present in the sample 15. Both have however signal for the [M+H+(NaCl)2]+
adduct. In total we have a match of 6 peaks between both spectra. The total
absence of the [M+H]+ ion in all samples from September 2020 (except the last 5)
is unexplainable especially since this ion is present in all other samples
analyzed. This can also not be explained by a strong retention time shift in
these samples, since no other peak is present for that m/z from 10 to 50 seconds
(in any sample).

```{r eval = FALSE, echo = FALSE}
plotSpectraMirror(sps[14], sps[15])
abline(v = std_info$mz_ion[i], lty = 3, col = "#ff000080")
## There's no other large signal for 15, so it can not be ion suppression.
```

At last we calculate also the pairwise similarity of all ion spectra with each
other and cluster them.

```{r sphingosine-spectra-correlation-heatmap, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 11, fig.height = 10}
cormat <- compareSpectra(sps_adds, ppm = 40)
ann <- pData(data_pos)[, "year_month", drop = FALSE]
rownames(ann) <- rownames(cormat)
ann$year_month <- factor(ann$year_month)
library(pheatmap)
pheatmap(cormat, annotation_col = ann,
         annotation_colors = list(year_month = col_year_month))
```

Samples from September 2020 (except the last 5 samples measured in that month)
have a different ion spectrum compared to all other samples.

Next we evaluate the signal for *Inosine*. This standard yields lower
intensities in the second batch from February 2020 (see below).

![](images/random_QC_samples/selected-standards/Inosine.png)

```{r}
i <- which(std_info$name == "Inosine")
sps <- std_sp[[i]]

adds <- mass2mz(std_info$mzneut[i],
                adduct = adducts(polarity = "positive"))[[1]]
adds <- sort(adds[adds > 0 & adds < 1000])

sps_adds <- filterMzValues(sps, mz = adds, ppm = 20)
```

Next we compare the ion spectrum for Inosine from samples 12 and 14 (both
measured in February 2020). Note: the full scan for sample 13 was extracted at a
potentially wrong retention time (see plot above).

```{r inosine-ion-spectrum-mirror-12-13, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 8, fig.height = 8}
plotSpectraMirror(sps_adds[12], sps_adds[14], ppm = 40,
                  main = paste0(std_info$name[i], "; sample 12/14"),
                  labels = label_function, labelPos = 4, labelSrt = 45)
abline(v = std_info$mz_ion[i], lty = 3, col = "#ff000080")
```

In the analyzed spectrum of sample 14 the [M+Na]+ ion as well as other ions
containing Na are present, but in a much lower concentration.

Could it be ion suppression that prevents creation of this ion? Evaluate the
ratio between the tic and the intensity of this ion.

```{r}
sps_tic <- vapply(mz(sps), sum, numeric(1), na.rm = TRUE)
```

Plotting the full MS data for sample 12

```{r}
## maybe need to get spectra left and right of the current one?
library(magrittr)
tmp <- data_pos %>%
    filterFile(12) %>%
    filterRt(c(135, 155 )) %>%
    filterMz(c(290.02, 292.09))
plot(tmp, type = "XIC")
abline(h = std_info$mz_ion[i], lty = 2)

## data_prof <- readMSData(dir("/data/massspec/mzML/profile/2020",
##                             full.names = TRUE, recursive = TRUE),
##                         mode = "onDisk")
## tmp <- data_prof %>%
##     filterRt(c(135, 155 )) %>%
##     filterMz(c(291.0, 291.1))
## plot(tmp, type = "XIC", col = NA)
## abline(h = std_info$mz_ion[i], lty = 2)
```

And the same for sample 14

```{r}
## maybe need to get spectra left and right of the current one?
library(magrittr)
tmp <- data_pos %>%
    filterFile(14) %>%
    filterRt(c(135, 155 )) %>%
    filterMz(c(290.02, 292.09))
plot(tmp, type = "XIC")
abline(h = std_info$mz_ion[i], lty = 2)
```

ion suppression? does the co-eluting signal interfere? Note that also profile
mode data looks the same.
- m/z of salt clusters?



Summary: no clear hint for a batch-specific ion formation.

TODO:
- for each standard: find all chrom peaks potentially matching an ion and sum up
  that intensities: are these values more reproducible?
- check some internal standards.
- check full scan for a standard that shows a bad pattern for 2017 samples.

# Session information

```{r}
sessionInfo()
```

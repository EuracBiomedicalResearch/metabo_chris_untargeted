---
title: "XCMS processing of the untargeted metabolomics data from CHRIS"
author: "Mar Garcia-Aloy, Johannes Rainer"
output:
  BiocStyle::html_document:
    toc: true
    number_sections: false
    toc_float: true
---

```{r startpoint, include = FALSE}
startpoint <- Sys.time()
```

In this document we're going to process the samples from CHRIS with XCMS.
For this study, peak detection has already been done for each sample separately.
Therefore, this file covers aligment, correspondence and peak filling.


# Preliminaries

We define the specific parameters for the current study,
We load all required libraries, and we set up the parallel processing.

## Parameters

```{r parameters}
polarity <- "POS" # specify "POS" or "NEG"
exclusion <- c("041016_BLANK_POS_1",
               "041016_BLANK_POS_2-041016_BLANK_POS_1",
               "041016_BLANK_POS_2",
               "041016_BLANK_POS_1 (3)",
               "041016_BLANK_POS_1 (4)",
               "06102032_BLANK_POS_b",
               "251016_BLANK_POS_1",
               "251016_BLANK_POS_2",
               "20161025_BLANK_POS_a",
               "20161025_BLANK_POS_b",
               "211116_BLANK_POS_1",
               "211116_BLANK_POS_2",
               "051216_BLANK_POS_1",
               "051216_BLANK_POS_2",
               "20161205_BLANK_POS_a",
               "20161205_BLANK_POS_b",
               "20161205_BLANK_POS_a_R",
               "20161205_BLANK_POS_a_R (2)",
               "20161205_BLANK_POS_b_R",
               "20161205_BLANK_POS_a_R1",
               "090117_BLANK_POS_1",
               "090117_BLANK_POS_2",
               "20170112_BLANK_POS_a",
               "20170112_BLANK_POS_b",
               "120117_BLANK_POS_1",
               "20170209_BLANK_POS_a",
               "20170406_BLANK_POS_a",
               "20170731_BLANK_POS (2)",

               "06102016_0010060146_POS",
               "20170615_0010282264_POS_R",

               "20161116_POOL_POS_2",
               "20170405_0010007645_POS",

               "20170209_BLANK_NEG_a",
               "20170209_BLANK_NEG_b",
               "20170220_BLANK_NEG_a",
               "20170220_BLANK_NEG_a (2)",
               "20170224_BLANK_NEG_a",
               "20170407_BLANK_NEG_a",
               "20170731_BLANK_NEG",
               "20170109_BLANK_NEG_a",
               "20170111_BLANK_NEG_a",
               "20170206_BLANK_NEG_a",
               "20170207_BLANK_NEG_a",

               "20161024_0010302963_NEG",
               "20161201_POOL_NEG_1.mzML",
               "20161201_POOL_NEG_2.mzML")
rt_cut <- 340

# DEFINE PATHS:
RData_PATH <- "/data/massspec/RData2/"
#RData_PATH <- "Y:/RData"
dir.create("data/", recursive = TRUE, showWarnings = FALSE)

IMAGE_PATH <- paste0("images/", polarity, "/")
dir.create(IMAGE_PATH, recursive = TRUE, showWarnings = FALSE)
```


## Libraries

```{r libraries, message = FALSE}
library(readxl)
library(RColorBrewer)
library(xcms)
```


## Parallel processing

```{r parallel-cluster, eval = TRUE}
ncores <- Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3)
register(bpstart(MulticoreParam(ncores)))
#register(SerialParam())
```


# Data import

```{r data-import}
#  Get filenames
injections <- as.data.frame(read_xlsx("data/chris-files-annotated.xlsx"))
injections$id <- gsub(".mzML", "", injections$mzML_file)
injections <- injections[order(injections$timestamp), ]
## injections$batch <- gsub(".*/", "", injections$mzML_file)
## injections$batch <- gsub("_.*", "", injections$batch)
injections$batch <- injections$run_id

## Alternative approach: subset injections.
injections <- injections[injections$polarity == polarity, ]
injections <- injections[!injections$type %in% c("ACN_IS", "EQ_MIX"), ]

injections <- injections[!injections$sample_name %in% exclusion, ]

fls <- sub("mzML", "RData", injections$mzML_file)
# number of peaks
npeaks <- c()

load(paste0(RData_PATH, fls[1]))
#xdata@processingData@files <- gsub("/data/massspec", "Y:", xdata@processingData@files)
npeaks <- c(npeaks, nrow(chromPeaks(xdata)))
data <- xdata

system.time(
for (i in 2:length(fls)) {
    load(paste0(RData_PATH, fls[i]))
    ## xdata@processingData@files <- gsub("/data/massspec", "Y:", xdata@processingData@files)
    npeaks <- c(npeaks, nrow(chromPeaks(xdata)))
    data <- c(data, xdata)
}
)
rm(xdata)

## Alternative, load all and pass that to `c`.

## Remove/cleanup the processHistory slot. No need to have x replicates there.

## Re-add/fill with phenoData.

tmp <- unique(data.frame(fromFile(data), polarity(data)))
table(tmp$polarity.data.)

if (polarity == "POS"){
  data <- filterFile(data, which(tmp$polarity.data. == 1))
} else if (polarity == "NEG"){
  data <- filterFile(data, which(tmp$polarity.data. == 0))
}
rm(tmp)

# Specify file name
#data$filename <- gsub("Y:/mzML/", "", fileNames(data))
data$filename <- fileNames(data)

# Specify class
data$class <- NA
data$class[grep("_001", data$filename)] <- "study_sample"
data$class[grep("BLANK", data$filename)] <- "blank"
data$class[grep("POOL", data$filename)] <- "pool"

# Specify batch
data$batch <- gsub("_.*", "", data$sampleNames)
```


## Coloring factors

```{r colors, echo = FALSE}
data$class <- factor(data$class)
col_class <- brewer.pal(length(levels(data$class)), "Set1")
names(col_class) <- levels(data$class)
sample_colors <- col_class[data$class]
plot(1, 1, xaxt = 'n', yaxt = 'n', bty = 'n', ylab = '', xlab = '',
     xlim = 0:1, ylim = 0:1)
legend("topleft", legend = names(col_class),
       col = col_class, pch = 16, pt.cex = 2, cex = 2,
       bty = 'n')

getPalette <- colorRampPalette(brewer.pal(9, "YlOrRd"))
col_batch <- getPalette(length(levels(factor(data$batch))))
names(col_batch) <- levels(factor(data$batch))
#sample_colors <- col_batch[data$batch]
plot(1, 1, xaxt = 'n', yaxt = 'n', bty = 'n', ylab = '', xlab = '',
     xlim = 0:1, ylim = 0:1)
legend("topleft", legend = names(col_batch),
       col = col_batch, pch = 16, pt.cex = 2, cex = 2,
       bty = 'n', ncol = 2)
```


## Study design summary

- *Who injected the samples?*
- *When they were injected?* 2016-2017
- *How many batches there are?* 63-POS ; 64-NEG
- *Is there any batch injected more than once?* yes (POS: 20170615-20170728 ; NEG: 20170609-20170623)
- *How many samples were injected by batch?* 80 study samples + 10 QCs + 1 blank + 15 EQ_MIX
- *Which was the scheme of each batch?* blank (x1) + EQ_MIX (x15) + [QC (x1) + study sample (x8)]x10
- *Which type of samples were analyzed?* serum samples


## Number of peaks

```{r npeaks-plot, eval = TRUE, fig.path = IMAGE_PATH}
npeaks <- data.frame(
  npeaks <- npeaks,
  mzML_file <- gsub("/data/massspec/mzML", "", data$filename),
  class <- data$class
)
colnames(npeaks) <- c("npeaks", "mzML_file", "class")

npeaks <- merge(injections, npeaks, by = "mzML_file")
npeaks <- npeaks[order(npeaks$timestamp), ]

plot(npeaks$npeaks,
     xlab= "injection order", ylab = "number of peaks",
     col = col_class[npeaks$class], pch = 20)
```


# RT filtering

Here we delete the signals with a RT higher than `r rt_cut` seconds.

```{r rt-filter}
xdata <- filterRt(data, rt = c(0, rt_cut))
```


# Aligment

Chromatographic peaks have to be aligned to adjust for any RT differences due to shifts or biases in the LC.
Alignment is also known as retention time correction and aims to adjust
the data set by signals that are shifted along the retention time axis to align samples
from the same experiment.
We will use the *peak groups* method, that aligns samples based on *hook* peaks that are present
in most samples. We thus first group chromatographic peaks requiring them to be
present in 75% of the samples within each group and use these as the *hook* peaks.
In most cases, it might be better to perform the alignment only on a subset of
the samples, in this case only on the QC samples and then use it to adjust the
full data set. The RTs are adjusted based on the RT of
the two nearest QC, giving more weight to the closer subset sample.
The subset (QC samples) has to be defined using the parameter
*subset*. The parameter *subsetAdjust* specifies the method by which the
left-out samples will be adjusted. Here, the subsetAdjust = "average" will be
used. It adjusts retentions times of non-subseted samples based on an
interpolation of the alignment results of the previous and subsequent subset
sample, thus, from results of neighboring subset/QC samples.

Below we perform the first peak grouping and subsequently the alignment.
For the alignment it is required a *hook* peak to be present in at least 75% of samples.

```{r aligment, eval = TRUE}
# Define the hook peaks
pdp1 <- PeakDensityParam(sampleGroups = xdata$class,
                         minFraction = 0.75,
                         bw = 3,
                         binSize = 0.02)
xdata <- groupChromPeaks(xdata, param = pdp1)

# Perform the aligment
pgp <- PeakGroupsParam(span = 0.3,
                       subset = which(xdata$class == "pool"),
                       subsetAdjust = "average",
                       minFraction = 0.9)
xdata <- adjustRtime(xdata, param = pgp)
```


## Checking

The results from the alignment are shown below.
To visualize the alignment results, the BPC for the whole data set is plotted.

```{r alignment-rtime-plot, eval = TRUE, fig.path = IMAGE_PATH, fig.width = 12, fig.height = 10}
#rts <- split(rtime(xdata), fromFile(xdata))
#rt_ranges = lapply(rts, range)
#rt_ranges_df <- do.call(rbind, rt_ranges)
chr_raw <- chromatogram(xdata, aggregationFun = "max",
                        adjustedRtime = FALSE, rt = c(0, 325))
chr_adj <- chromatogram(xdata, aggregationFun = "max", rt = c(0, 325))

par(mfrow = c(3, 1), mar = c(0, 4.3, 2, 0.1))
plot(chr_raw, col = paste0(col_class[chr_raw$class], 40),
     peakType = "none", main = "BPC, raw")
plot(chr_adj, col = paste0(col_class[chr_raw$class], 40),
     peakType = "none", main = "BPC, adjusted")
plotAdjustedRtime(xdata, col = paste0(col_class[xdata$class], 80))
```


# Correspondance

Correspondence aims to group chromatographic peaks of the same ion across samples.
Usually, we re-use settings for the grouping performed already in the previous
section, but reduce the `minFraction` parameter to 30% in order to
allow definition of features that are present in fewer individuals.

```{r correspondance, eval = TRUE}
pdp2 <- PeakDensityParam(sampleGroups = xdata$class,
                         minFraction = 0.3,
                         bw = 2,
                         binSize = 0.02)
xdata <- groupChromPeaks(xdata, param = pdp2)
```



# Save data

```{r save, eval = TRUE}
save(xdata, file = paste0("data/data_XCMS_", polarity,".RData"))
```


# Session information
```{r session}
Sys.time()-startpoint

devtools::session_info()
```

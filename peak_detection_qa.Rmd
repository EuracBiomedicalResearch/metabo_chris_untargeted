---
title: "Quality assessment of the CHRIS untargeted peak detection"
author: "Johannes Rainer"
output:
  BiocStyle::html_document:
    toc: true
    number_sections: false
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
---

```{r biocstyle, echo = FALSE, results = "asis" }
library(BiocStyle)
BiocStyle::markdown()
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

**Modified**: `r file.info("peak_detection_qa.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = FALSE}
## Set general options
options(useFancyQuotes = FALSE)
set.seed(123)

## Define paths:
FILE_NAME <- "peak_detection_qa"
## Path to save the images; remove all old images.
IMAGE_PATH <- paste0("images/", FILE_NAME, "/")
if (dir.exists(IMAGE_PATH)) unlink(IMAGE_PATH, recursive = TRUE, force = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE, showWarnings = FALSE)
## Path to store RData files
RDATA_PATH <- paste0("data/RData/", FILE_NAME, "/")
dir.create(RDATA_PATH, recursive = TRUE, showWarnings = FALSE)

## Get the number of cpus allocated or fall back to 3
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 4))

rt_cut <- 340

MZML_PATH <- "/data/massspec/mzML/"
if (!dir.exists(MZML_PATH))
    stop("Can not find the directory with the mzML files: ", MZML_PATH)

```

# Introduction

In this document we perform a quality assessment of the peak detection step of
the CHRIS untargeted metabolomics data (defined and performed in
[peak_detection.Rmd](peak_detection.Rmd). The quality assessment is performed on
the QC samples from each batch of the data set, which represent repeated
measurement of the same original samples (the *CHRIS POOL*). Also, retention
time drifts and intensity differences are evaluated on chromatographic peaks
representing signal from internal standards or a set of known compounds (the
lab-specific standards).

# Data import

We next load all required libraries and the data. The full data set is reduced
to only QC samples.

```{r libraries}
library(xcms)
library(Rdisop)
library(pander)
library(RColorBrewer)
library(MetaboCoreUtils)

register(bpstart(MulticoreParam(ncores, progressbar = TRUE)))

load("data/RData/peak_detection/data_pos_ref.RData")
blnk_pos <- filterFile(data_pos, file = which(data_pos$type == "BLANK"))
qc_pos <- filterFile(data_pos, file = which(data_pos$type == "QC"))
rm(data_pos)
load("data/RData/peak_detection/data_neg_ref.RData")
blnk_neg <- filterFile(data_neg, file = which(data_neg$type == "BLANK"))
qc_neg <- filterFile(data_neg, file = which(data_neg$type == "QC"))
rm(data_neg)

## Load the base peak chromatogram data
load("data/RData/peak_detection/bpc_pos.RData")
bpc_qc_pos <- bpc_pos[, which(bpc_pos$type == "QC")]
rm(bpc_pos)
load("data/RData/peak_detection/bpc_neg.RData")
bpc_qc_neg <- bpc_neg[, which(bpc_neg$type == "QC")]
rm(bpc_neg)

## At last define colors for each batch.
btches <- union(unique(qc_pos$batch), unique(qc_neg$batch))
## Ordering can be tricky because we have 12 and 104, so 104 would be
## ordered before 12.
btch_mod <- sapply(btches, function(x) {
    tmp <- strsplit(x, "_")[[1L]]
    paste0(tmp[1L], "_",
           ifelse(nchar(tmp[2L]) == 2L, yes = "0", no = ""),
           tmp[2L])
})
btches <- btches[order(btch_mod)]
col_batch <- rainbow(length(btches))
names(col_batch) <- btches
```


# Global quality assessment

For the global quality assessment we evaluate and compare the signal in QC
samples across all batches. At first we compare the average number of identified
chromatographic peaks in QC samples per batch.

```{r peak-counts, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 7, fig.height = 7, fig.cap = "Average number of detected peaks in QC samples per batch. Batches are ordered by measurement time."}
label_year <- function(x, ypos = 10000) {
    yrs <- vapply(strsplit(names(x), "_"),
                  function(x) as.integer(x[1]), integer(1))
    year_change <- c(1, which(diff(yrs) > 0))
    abline(v = year_change, lty = 2)
    text(x = year_change, y = rep(ypos, length(year_change)),
         labels = yrs[year_change + 1], pos = 4)
}

pks_pos <- table(factor(as.integer(chromPeaks(qc_pos)[, "sample"]),
                        levels = seq_along(fileNames(qc_pos))))
pks_pos <- split(pks_pos, f = qc_pos$batch)
pks_pos <- vapply(pks_pos, mean, numeric(1))
## negative
pks_neg <- table(factor(as.integer(chromPeaks(qc_neg)[, "sample"]),
                        levels = seq_along(fileNames(qc_neg))))
pks_neg <- split(pks_neg, f = qc_neg$batch)
pks_neg <- vapply(pks_neg, mean, numeric(1))
par(mfrow = c(2, 1), mar = c(1, 4.5, 1, 1))
plot(y = pks_pos, x = seq_along(pks_pos), bg = col_batch[names(pks_pos)],
     main = "positive polarity", xaxt = "n", ylab = "average peak count",
     pch = 21, xlab = "")
grid()
label_year(pks_pos, ypos = 10000)
plot(y = pks_neg, x = seq_along(pks_neg), bg = col_batch[names(pks_neg)],
     main = "negative polarity", xaxt = "n", ylab = "average peak count",
     pch = 21, xlab = "")
grid()
label_year(pks_neg, ypos = 9000)
```

The average number of identified peaks in QC samples varies considerably between
batches (over time). The highest number was detected in the last four batches
from 2017. The number of peaks per individual QC sample matches well with the
average number per batch (data not shown here). Note that this is related to the
average intensity across batches which we plot below.

```{r peak-count-individual-qc-samples, echo = FALSE}
## Peak counts for individual QC samples.
png("peak-count-qc-samples.png", width = 18, height = 8, units = "cm",
    pointsize = 4, res = 300)
year_change <- c(1, which(diff(as.numeric(qc_pos$year)) > 0) + 1)
intos <- split(log2(chromPeaks(qc_pos)[, "into"]),
               chromPeaks(qc_pos)[, "sample"])
par(mfrow = c(2, 1), mar = c(2, 4.3, 1.5, 0.5))
tmp <- barplot(lengths(intos), col = col_batch[qc_pos$batch],
               ylab = "peak count", main = "QC samples, positive polarity",
               xaxt = "n", border = "#00000040")
abline(v = tmp[year_change, 1], lty = 2)
text(x = tmp[year_change, ], y = rep(10000, length(year_change)),
     labels = qc_pos$year[year_change], pos = 4)
## Negative polarity
year_change <- c(1, which(diff(as.numeric(qc_neg$year)) > 0) + 1)
intos <- split(log2(chromPeaks(qc_neg)[, "into"]),
               chromPeaks(qc_neg)[, "sample"])
tmp <- barplot(lengths(intos), col = col_batch[qc_neg$batch],
               ylab = "peak count", main = "QC samples, negative polarity",
               xaxt = "n", border = "#00000040")
abline(v = tmp[year_change, 1], lty = 2)
text(x = tmp[year_change, ], y = rep(9000, length(year_change)),
     labels = qc_neg$year[year_change], pos = 4)
dev.off()
```

```{r bpc-boxplots-qc-samples, fig.path = IMAGE_PATH, echo = FALSE, fig.width = 12, fig.height = 8, fig.cap = "Per-sample base peak chromatogram (BPC) intensity distribution."}
## Generate the BPC signal distribution.
ints <- lapply(bpc_qc_pos, intensity)
ints <- lapply(ints, log2)
par(mar = c(2, 4.3, 1.5, 0.5), mfrow = c(2, 1))
tmp <- boxplot(ints, varwidth = TRUE, col = col_batch[bpc_qc_pos$batch],
               outline = FALSE, main = "QC samples",
               ylab = expression(log[2]~base~peak~signal),
               border = "#00000040")
year_change <- c(1, which(diff(as.numeric(bpc_qc_pos$year)) > 0) + 1)
abline(v = year_change, lty = 2)
text(x = year_change, y = rep(19, length(year_change)),
     labels = bpc_qc_pos$year[year_change], pos = 4)
## Neg polarity
ints <- lapply(bpc_qc_neg, intensity)
ints <- lapply(ints, log2)
tmp <- boxplot(ints, varwidth = TRUE, col = col_batch[bpc_qc_neg$batch],
               outline = FALSE, main = "QC samples, negative polarity",
               ylab = expression(log[2]~base~peak~signal),
               border = "#00000040")
year_change <- c(1, which(diff(as.numeric(bpc_qc_neg$year)) > 0) + 1)
abline(v = year_change, lty = 2)
text(x = year_change, y = rep(18, length(year_change)),
     labels = bpc_qc_neg$year[year_change], pos = 4)
```

Positive and negative mode data was not generated at the same (or consecutive)
time which explains the differences in drifts observed for the base peak signal
in positive and negative data (see Figure above).

At last we create also the BPC for positive and negative data.

```{r bpc-plot-qc-samples, fig.path = IMAGE_PATH, echo = FALSE, fig.width = 12, fig.height = 8, fig.cap = "Base peak chromatograms."}
par(mar = c(4.5, 4.3, 1.5, 0.5), mfrow = c(2, 1))
plot(bpc_qc_pos, col = paste0(col_batch[bpc_qc_pos$batch], 20),
     main = "BPC, QC samples, positive polarity")
plot(bpc_qc_neg, col = paste0(col_batch[bpc_qc_neg$batch], 20),
     main = "BPC, QC samples, negative polarity")
```

The BPC look more or less similar, but some drifts are observable.

Next we specifically evaluate the signal from internal standards and lab
standards.


## Internal standards


Next we evaluate the signal of peaks for internal standards in the data set. To
this end we first load the definition of internal standards (i.e. their expected
m/z and retention time), identify chromatographic peaks in the data set
potentially matching these and plot this data (code not shown).

```{r is, echo = FALSE, eval = FALSE}
is_info <- read.table(
    "https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/internal_standards.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
rownames(is_info) <- is_info$name
is_info <- is_info[order(is_info$name), ]
is_info$mzneut = NA
is_info$mz_ion_pos = NA
is_info$mz_ion_neg = NA
for (i in seq(nrow(is_info))) {
    if (grepl("C", is_info$formula[i])){
        is_info$mzneut[i] <- getMolecule(
            as.character(is_info$formula[i]))$exactmass
    } else
        is_info$mzneut[i] = as.numeric(is_info$formula[i])
    ## Calculate also the m/z
    if (!is.na(is_info$POS[i]))
        is_info$mz_ion_pos[i] <-
            mass2mz(is_info$mzneut[i], adduct = is_info$POS[i])[1, 1]
    if (!is.na(is_info$NEG[i]))
        is_info$mz_ion_neg[i] <-
            mass2mz(is_info$mzneut[i], adduct = is_info$NEG[i])[1, 1]
}
is_pos <- is_info[!is.na(is_info$mz_ion_pos), ]
is_pos$mz_ion <- is_pos$mz_ion_pos
is_neg <- is_info[!is.na(is_info$mz_ion_neg), ]
is_neg$mz_ion <- is_neg$mz_ion_neg

#' @description
#'
#' Define m/z and retention time ranges of all chromatographic peaks in `x` that
#' match the provided m/z and retention time values.
#'
#' @param x `XCMSnExp` object with identified chromatographic peaks.
#'
#' @param mz `numeric` with m/z values for which chromatographic peaks should
#'     be found.
#'
#' @param rt `numeric` with retention time values for which chromatographic
#'     peaks should be found.
#'
#' @param diffRt `numeric(1)` with the maximal allowed difference between `rt`
#'     and the chromatographic peak's retention time.
#'
#' @param ppm `numeric(1)` with the allowed difference between `mz` and the
#'     chromatographic peak's m/z.
#'
#' @return `matrix` with columnd `"mzmin"`, `"mzmax"`, `"rtmin"`, `"rtmax"`
#'     with the m/z and retention time ranges calculated on all chromatographic
#'     peaks in `x` matching `mz` and `rt`. Each row representing the result for
#'     each value in `mz` and `rt`.
#'
#' @note Add this to CompMetaboTools???
#'
#' @author Johannes Rainer
peak_regions_for_mz_rt <- function(x, mz, rt, diffRt = 40, ppm = 50) {
    if (!hasChromPeaks(x))
        stop("No chromatographic peaks in 'x'. Please run `findChromPeaks' first.")
    l <- length(mz)
    if (l != length(rt))
        stop("'mz' and 'rt' have to have the same length.")
    res <- matrix(ncol = 4, nrow = l,
                  dimnames = list(NULL, c("mzmin", "mzmax", "rtmin", "rtmax")))
    for (i in seq_len(l)) {
        pks <- chromPeaks(x, mz = mz[i], ppm = ppm)
        if (nrow(pks)) {
            keep <- which(abs(pks[, "rt"] - rt[i]) < diffRt)
            if (length(keep)) {
                pks <- pks[keep, , drop = FALSE]
                res[i, ] <- c(range(pks[, c("mzmin", "mzmax")]),
                              range(pks[, c("rtmin", "rtmax")]))
            }
        }
    }
    res
}

plot_chrs <- function(x, dir, prefix = "IS-", suffix = "_POS", rect = TRUE) {
    sample_colors <- col_batch[x$batch]
    for (i in seq_len(nrow(x))) {
        cmpname <- fData(x)$name[i]
        filename <- paste0(dr, prefix, gsub("%", "p", cmpname, fixed = TRUE),
                           suffix, ".png")
        png(file = filename, width = 16, height = 8, units = "cm",
            res = 300, pointsize = 4)
        chr <- x[i, ]
        pks <- chromPeaks(chr)
        plot(chr, col = "#00000040",
             main = paste0(cmpname, ": ",
                           format(mz(chr)[1], digits = 6), "-",
                           format(mz(chr)[2], digits = 6)),
             peakCol = paste0(sample_colors[pks[, "column"]], 50),
             peakBg = paste0(sample_colors[pks[, "column"]], 10))
        ## This is just to indicate identified peaks with a rectangle.
        if (rect)
            xcms:::.add_chromatogram_peaks(
                       chr, pks,
                       col = paste0(sample_colors[pks[, "column"]], 10),
                       bg = NA,
                       type = "rectangle")
        abline(v = fData(x)$RT[i])
        dev.off()
    }
}

is_pos_mz_rt <- peak_regions_for_mz_rt(
    qc_pos, mz = is_pos$mz_ion, rt = is_pos$RT)
is_pos <- is_pos[!is.na(is_pos_mz_rt[, "mzmin"]), ]
is_pos_mz_rt <- is_pos_mz_rt[!is.na(is_pos_mz_rt[, "mzmin"]), ]
## Extract the ion chromatogram for each standard
rtr <- is_pos_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
is_pos_chr <- chromatogram(
    qc_pos, mz = is_pos_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
fData(is_pos_chr) <- cbind(
    fData(is_pos_chr), is_pos[, c("name", "abbreviation", "formula",
                                  "POS", "RT")])

## Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
plot_chrs(is_pos_chr, dr)

## Define the rt window for standards that look ~ OK.
is_pos$rtmin <- NA_real_
is_pos$rtmax <- NA_real_
is_pos$rtmin[is_pos$name == "Glycine (13C2, 99%; 15N, 99%)"] <- 165
is_pos$rtmax[is_pos$name == "Glycine (13C2, 99%; 15N, 99%)"] <- 183
is_pos$rtmin[is_pos$name == "L-Alanine (13C3, 99%; 15N, 99%)"] <- 160
is_pos$rtmax[is_pos$name == "L-Alanine (13C3, 99%; 15N, 99%)"] <- 180
is_pos$rtmin[is_pos$name == "L-Arginine HCl (13C6, 99%; 15N4, 99%)"] <- 165
is_pos$rtmax[is_pos$name == "L-Arginine HCl (13C6, 99%; 15N4, 99%)"] <- 220
is_pos$rtmin[is_pos$name == "L-Aspartic acid (13C4, 99%; 15N, 99%)"] <- 170
is_pos$rtmax[is_pos$name == "L-Aspartic acid (13C4, 99%; 15N, 99%)"] <- 210
is_pos$rtmin[is_pos$name == "L-Cystine (13C6, 99%; 15N2, 99%)"] <- 205
is_pos$rtmax[is_pos$name == "L-Cystine (13C6, 99%; 15N2, 99%)"] <- 230
is_pos$rtmin[is_pos$name == "L-Glutamic acid (13C5, 99%; 15N, 99%)"] <- 158
is_pos$rtmax[is_pos$name == "L-Glutamic acid (13C5, 99%; 15N, 99%)"] <- 200
is_pos$rtmin[is_pos$name == "L-Histidine HCl H2O (13C6; 15N3, 99%)"] <- 165
is_pos$rtmax[is_pos$name == "L-Histidine HCl H2O (13C6; 15N3, 99%)"] <- 240
is_pos$rtmin[is_pos$name == "L-Lysine 2HCl (13C6, 99%; 15N2, 99%)"] <- 174
is_pos$rtmax[is_pos$name == "L-Lysine 2HCl (13C6, 99%; 15N2, 99%)"] <- 215
is_pos$rtmin[is_pos$name == "L-Methionine (13C5, 99%; 15N, 99%)"] <- 150
is_pos$rtmax[is_pos$name == "L-Methionine (13C5, 99%; 15N, 99%)"] <- 165
is_pos$rtmin[is_pos$name == "L-Phenylalanine (13C9, 99%; 15N, 99%)"] <- 135
is_pos$rtmax[is_pos$name == "L-Phenylalanine (13C9, 99%; 15N, 99%)"] <- 160
is_pos$rtmin[is_pos$name == "L-Proline (13C5, 99%; 15N, 99%)"] <- 158
is_pos$rtmax[is_pos$name == "L-Proline (13C5, 99%; 15N, 99%)"] <- 185
is_pos$rtmin[is_pos$name == "L-Serine (13C3, 99%; 15N, 99%)"] <- 175
is_pos$rtmax[is_pos$name == "L-Serine (13C3, 99%; 15N, 99%)"] <- 195
is_pos$rtmin[is_pos$name == "L-Threonine (13C4, 99%; 15N, 99%)"] <- 165
is_pos$rtmax[is_pos$name == "L-Threonine (13C4, 99%; 15N, 99%)"] <- 190
is_pos$rtmin[is_pos$name == "L-Tyrosine (13C9, 99%; 15N, 99%)"] <- 155
is_pos$rtmax[is_pos$name == "L-Tyrosine (13C9, 99%; 15N, 99%)"] <- 185
is_pos <- is_pos[!is.na(is_pos$rtmin), ]

## Re-create the m/z and rt range matrix
is_pos_mz_rt <- matrix(
    ncol = 4, nrow = nrow(is_pos),
    dimnames = list(is_pos$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(is_pos)) {
    pks <- chromPeaks(qc_pos, mz = is_pos$mz_ion[i], ppm = 50,
                      rt = c(is_pos$rtmin[i], is_pos$rtmax[i]))
    if (nrow(pks)) {
        mzr <- range(pks[, c("mzmin", "mzmax")])
        rtr <- range(pks[, c("rtmin", "rtmax")], is_pos$RT[i])
        rtr[1] <- rtr[1] - 1
        rtr[2] <- rtr[2] + 1
        is_pos_mz_rt[i, ] <- c(mzr, rtr)
    }
}
is_pos_chr <- chromatogram(
    qc_pos, mz = is_pos_mz_rt[, c("mzmin", "mzmax")],
    rt = is_pos_mz_rt[, c("rtmin", "rtmax")],
    aggregationFun = "max", include = "apex_within")
fData(is_pos_chr) <- cbind(
    fData(is_pos_chr), is_pos[, c("name", "abbreviation", "formula",
                                  "POS", "RT")])

## For each IS (row), in each sample (column) keep the chrom peak with the
## highest peak.
is_pos_chr <- filterChromPeaks(is_pos_chr, method = "keepTop",
                               n = 1L, order = "maxo")
save(is_pos_chr, file = paste0(RDATA_PATH, "is_pos_chr.RData"))
## Plot again.
plot_chrs(is_pos_chr, dr, prefix = "IS-", suffix = "-refined_POS", rect = FALSE)


## --------------------------------------------------
## Repeat for negative polarity.
is_neg_mz_rt <- peak_regions_for_mz_rt(
    qc_neg, mz = is_neg$mz_ion, rt = is_neg$RT)
is_neg <- is_neg[!is.na(is_neg_mz_rt[, "mzmin"]), ]
is_neg_mz_rt <- is_neg_mz_rt[!is.na(is_neg_mz_rt[, "mzmin"]), ]
## Extract the ion chromatogram for each standard
rtr <- is_neg_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
is_neg_chr <- chromatogram(
    qc_neg, mz = is_neg_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
fData(is_neg_chr) <- cbind(
    fData(is_neg_chr), is_neg[, c("name", "abbreviation", "formula",
                                  "NEG", "RT")])

## Plot the extracted ion chromatograms
plot_chrs(is_neg_chr, dr, prefix = "IS-", suffix = "_NEG")

## Define the rt window for standards that look ~ OK.
is_neg$rtmin <- NA_real_
is_neg$rtmax <- NA_real_
is_neg$rtmin[is_neg$name == "Creatinine (N-Methhyl_D3)"] <- 120
is_neg$rtmax[is_neg$name == "Creatinine (N-Methhyl_D3)"] <- 145
is_neg$rtmin[is_neg$name == "L-Alanine (13C3, 99%; 15N, 99%)"] <- 175
is_neg$rtmax[is_neg$name == "L-Alanine (13C3, 99%; 15N, 99%)"] <- 187
is_neg$rtmin[is_neg$name == "L-Arginine HCl (13C6, 99%; 15N4, 99%)"] <- 175
is_neg$rtmax[is_neg$name == "L-Arginine HCl (13C6, 99%; 15N4, 99%)"] <- 200
is_neg$rtmin[is_neg$name == "L-Aspartic acid (13C4, 99%; 15N, 99%)"] <- 170
is_neg$rtmax[is_neg$name == "L-Aspartic acid (13C4, 99%; 15N, 99%)"] <- 200
is_neg$rtmin[is_neg$name == "L-Cystine (13C6, 99%; 15N2, 99%)"] <- 202
is_neg$rtmax[is_neg$name == "L-Cystine (13C6, 99%; 15N2, 99%)"] <- 230
is_neg$rtmin[is_neg$name == "L-Glutamic acid (13C5, 99%; 15N, 99%)"] <- 165
is_neg$rtmax[is_neg$name == "L-Glutamic acid (13C5, 99%; 15N, 99%)"] <- 200
is_neg$rtmin[is_neg$name == "L-Histidine HCl H2O (13C6; 15N3, 99%)"] <- 175
is_neg$rtmax[is_neg$name == "L-Histidine HCl H2O (13C6; 15N3, 99%)"] <- 205
is_neg$rtmin[is_neg$name == "L-Lysine 2HCl (13C6, 99%; 15N2, 99%)"] <- 175
is_neg$rtmax[is_neg$name == "L-Lysine 2HCl (13C6, 99%; 15N2, 99%)"] <- 205
is_neg$rtmin[is_neg$name == "L-Methionine (13C5, 99%; 15N, 99%)"] <- 155
is_neg$rtmax[is_neg$name == "L-Methionine (13C5, 99%; 15N, 99%)"] <- 170
is_neg$rtmin[is_neg$name == "L-Phenylalanine (13C9, 99%; 15N, 99%)"] <- 140
is_neg$rtmax[is_neg$name == "L-Phenylalanine (13C9, 99%; 15N, 99%)"] <- 161
is_neg$rtmin[is_neg$name == "L-Serine (13C3, 99%; 15N, 99%)"] <- 172
is_neg$rtmax[is_neg$name == "L-Serine (13C3, 99%; 15N, 99%)"] <- 190
is_neg$rtmin[is_neg$name == "L-Threonine (13C4, 99%; 15N, 99%)"] <- 163
is_neg$rtmax[is_neg$name == "L-Threonine (13C4, 99%; 15N, 99%)"] <- 183
is_neg$rtmin[is_neg$name == "L-Tyrosine (13C9, 99%; 15N, 99%)"] <- 160
is_neg$rtmax[is_neg$name == "L-Tyrosine (13C9, 99%; 15N, 99%)"] <- 175
is_neg$rtmin[is_neg$name == "L-Valine (13C5, 99%; 15N, 99%)"] <- 160
is_neg$rtmax[is_neg$name == "L-Valine (13C5, 99%; 15N, 99%)"] <- 175
is_neg <- is_neg[!is.na(is_neg$rtmin), ]

## Re-create the m/z and rt range matrix
is_neg_mz_rt <- matrix(
    ncol = 4, nrow = nrow(is_neg),
    dimnames = list(is_neg$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(is_neg)) {
    pks <- chromPeaks(qc_neg, mz = is_neg$mz_ion[i], ppm = 50,
                      rt = c(is_neg$rtmin[i], is_neg$rtmax[i]))
    if (nrow(pks)) {
        mzr <- range(pks[, c("mzmin", "mzmax")])
        rtr <- range(pks[, c("rtmin", "rtmax")], is_neg$RT[i])
        rtr[1] <- rtr[1] - 1
        rtr[2] <- rtr[2] + 1
        is_neg_mz_rt[i, ] <- c(mzr, rtr)
    }
}
is_neg_chr <- chromatogram(
    qc_neg, mz = is_neg_mz_rt[, c("mzmin", "mzmax")],
    rt = is_neg_mz_rt[, c("rtmin", "rtmax")],
    aggregationFun = "max", include = "apex_within")
fData(is_neg_chr) <- cbind(
    fData(is_neg_chr), is_neg[, c("name", "abbreviation", "formula",
                                  "NEG", "RT")])

## For each IS (row), in each sample (column) keep the chrom peak with the
## highest peak.
is_neg_chr <- filterChromPeaks(is_neg_chr, method = "keepTop",
                               n = 1L, order = "maxo")
save(is_neg_chr, file = paste0(RDATA_PATH, "is_neg_chr.RData"))
## Plot again.
plot_chrs(is_neg_chr, dr, prefix = "IS-", suffix = "-refined_NEG", rect = FALSE)

```

Next we quantify the signal for the internal standards for each sample. For
samples in which more than one chromatographic peak is present in the retention
time region, the one with the higher signal is used. We're next evaluating the
retention time drifts and signal/abundance differences for the such defined
internal standard data sets (positive and negative polarity).

### Evaluating retention time drifts

In this section we evaluate drifts in retention times for the internal
standards. We calculate first for each standard the average retention time and
its standard deviation within each batch and calculate next the standard
deviation of the average retention times across batches.

```{r rt-sd-mean}
load(paste0(RDATA_PATH, "is_pos_chr.RData"))
load(paste0(RDATA_PATH, "is_neg_chr.RData"))

#' Per standard and batch summaries (mean and sd for into and rt
batch_summary <- function(x) {
    tmp <- chromPeaks(x)
    tmp <- data.frame(pData(x)[tmp[, "sample"],
                               c("batch", "year", "month", "day")], tmp)
    ## split by row/standard
    tmpl <- split(tmp, tmp$row)
    res <- lapply(tmpl, function(z) {
        btch <- split(z, factor(z$batch,
                                levels = unique(z$batch, fromLast = TRUE)))
        do.call(rbind, lapply(btch, function(vals) {
            data.frame(batch = vals$batch[1L],
                       year = vals$year[1L],
                       month = vals$month[1L],
                       day = vals$day[1L],
                       row = vals$row[1L],
                       rt_mean = mean(vals$rt, na.rm = TRUE),
                       rt_sd = sd(vals$rt, na.rm = TRUE),
                       into_mean = mean(vals$into, na.rm = TRUE),
                       into_sd = sd(vals$into, na.rm = TRUE))
        }))
    })
    res <- do.call(rbind, res)
    res <- cbind(fData(x)[res$row, ], res)
    rownames(res) <- NULL
    res
}

batch_sum_pos <- batch_summary(is_pos_chr)
batch_sum_neg <- batch_summary(is_neg_chr)
```

```{r rt-within-between-batch, fig.path = IMAGE_PATH, fig.width = 8, fig.height = 4, fig.cap = "Evaluation of within and between batch retention time shifts. Each point represents one internal standard. X-axis: mean within-batch standard deviation of retention times. Y-axis: standard deviation of within-batch mean retention times.", echo = FALSE}
par(mfrow = c(1, 2))
tmp <- split(batch_sum_pos, batch_sum_pos$name)
## Calculate mean across within batch sd and
tmp_pos <- do.call(rbind, lapply(tmp, function(z) {
    c(mean_sd = mean(z$rt_sd, na.rm = TRUE),
      sd_mean = sd(z$rt_mean, na.rm = TRUE))
}))
plot(tmp_pos[, 1], tmp_pos[, 2], main = "positive polarity",
     xlab = "average sd of RT", ylab = "sd of average RT")
tmp <- split(batch_sum_neg, batch_sum_neg$name)
## Calculate mean across within batch sd and
tmp_neg <- do.call(rbind, lapply(tmp, function(z) {
    c(mean_sd = mean(z$rt_sd, na.rm = TRUE),
      sd_mean = sd(z$rt_mean, na.rm = TRUE))
}))
plot(tmp_neg[, 1], tmp_neg[, 2], main = "negative polarity",
     xlab = "average sd of RT", ylab = "sd of average RT")
```

As expected, the within-batch variation of retention times is on average much
smaller than the variation of the per-batch average retention time across the
data set. Three of the internal standards show exceptionally large variation
across batches. These are `r paste0(rownames(tmp_pos[order(tmp_pos[,
2]),])[1:3], collapse = ", ")` for positive and `r
paste0(rownames(tmp_neg[order(tmp_neg[, 2]),])[1:3], collapse = ", ")` for
negative polarity.

We next evaluate the retention time shifts for the individual standards. We base
this on the average retention time of each standard in each batch (since we've
shown above that the retention time shifts within each batch are much smaller
than between batches).

```{r rt-per-analyte-boxplot, fig.path = IMAGE_PATH, echo = FALSE, fig.width = 10, fig.height = 8, fig.cap = "Variation of internal standards' retention times across batches."}
batch_sum_pos_analyte <- split(batch_sum_pos, batch_sum_pos$name)
batch_sum_neg_analyte <- split(batch_sum_neg, batch_sum_neg$name)

rt_pos <- lapply(batch_sum_pos_analyte, function(z) z$rt_mean)
rt_pos <- rt_pos[order(vapply(rt_pos, mean, numeric(1)))]
rt_neg <- lapply(batch_sum_neg_analyte, function(z) z$rt_mean)
rt_neg <- rt_neg[order(vapply(rt_neg, mean, numeric(1)))]

par(mfrow = c(1, 2), mar = c(9, 4, 1, 0.5))
boxplot(rt_pos, las = 2, ylab = "RT", main = "positive polarity")
grid()
boxplot(rt_neg, las = 2, ylab = "RT", main = "negative polarity")
grid()
```

The variation in retention times seems to be larger for analytes eluting between
185 and 195 seconds. Next we investigate whether retention time shift are
*constant* per batch, i.e. whether all standards within a batch show the same
retention time shift.

```{r rt-per-analyte-lines, fig.path = IMAGE_PATH, echo = FALSE, fig.width = 10, fig.height = 12, fig.cap = "Per individual internal standard (within-batch average) retention time across batches."}
par(mfrow = c(2, 1), mar = c(7, 4.5, 1, 0.5))
btches <- unique(is_pos_chr$batch)
yl <- range(lapply(rt_pos, range))
xl <- c(1, length(btches))
plot(3, 3, pch = NA, xlim = xl, ylim = yl, xlab = "", xaxt = "n",
     ylab = "RT", main = "positive polarity")
grid()
tmp <- lapply(batch_sum_pos_analyte,
              function(z) points(x = match(z$batch, btches), y = z$rt_mean,
                                 type = "l", col = "#00000060"))
axis(side = 1, at = seq_along(btches),
     label = btches, las = 2)

btches <- unique(is_neg_chr$batch)
yl <- range(lapply(rt_neg, range))
xl <- c(1, length(btches))
plot(3, 3, pch = NA, xlim = xl, ylim = yl, xlab = "", xaxt = "n",
     ylab = "RT", main = "negative polarity")
grid()
tmp <- lapply(batch_sum_neg_analyte,
              function(z) points(x = match(z$batch, btches), y = z$rt_mean,
                                 type = "l", col = "#00000060"))
axis(side = 1, at = seq_along(btches),
     label = btches, las = 2)

```

The lines representing the retention times of individual internal standards show
about the same pattern across batches. Thus retention times of individual
standards appear to be affected by a similar shift within each batch. It should
hence be possible to align the samples without too large problems.


### Evaluating signal abundances

- boxplot of IS (per batch or sample) indicating also the mean BPI and the mean
  into of the 200 highest abundant peaks.

```{r is-quantify}


```


- Manually assign peaks to IS -> quantify
- Boxplot: IS concentrations, add mean BPC and mean peak signal of top 200
  peaks per sample.
- RSD and retention time drifts for the IS.
- Repeat for known compounds.

## Evaluating the *dilution QC samples*

- check how the QC dilution look.

# Per-batch quality assessment

In this section we evaluate the signal within each batch, comparing the data
from study samples against those of the QC samples.

# Session information

```{r}
sessionInfo()
```
